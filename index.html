// ====================================================================
// ===================     THƯ VIỆN CHO ESP32     =====================
// ====================================================================
#include <WiFi.h>
#include <ESPAsyncWebServer.h>
#include <WebSocketsServer.h>
#include <ArduinoJson.h>
#include <Preferences.h>
#include "FS.h"
#include "SPIFFS.h"
#include <time.h>
#include <Ticker.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <PubSubClient.h>
#include <WiFiClientSecure.h>
#include <Wire.h>
#include "RTClib.h"
#include <LiquidCrystal_PCF8574.h>
#include "esp_partition.h"
#include <esp_ota_ops.h>
#include <Update.h>
#include "DYPlayer.h"

// ====================================================================
// ===================   KHAI BÁO CÁC HÀM (FORWARD DECLARATION)   =====
// ====================================================================
// Hàm cho MQTT & Cấu hình
void saveNetworkConfig(bool use_static, const char* ip, const char* gateway, const char* subnet, const char* dns);
void loadMqttConfig();
void saveMqttConfig(const char* server, int port, const char* user, const char* pass);
bool connectMQTTWithRetries();
void reconnectMQTT();
void callback(char* topic, byte* payload, unsigned int length);
void publishStateToMqtt();
void saveAdminPassword();
void loadAdminPassword();
void sendMusicStatusToClient(uint8_t num);
void sendSatelliteStatusToClient(uint8_t num); // <-- THÊM DÒNG NÀY
void createDefaultData();
void readAllData();
void saveAllData();
void broadcastAndPublishState();
void controlRelay(int num);
void saveHolidayData();
void readHolidayData();
void saveScenarioData(); 
void loadScenarioData(); 
void syncTimeWithNTP();
void checkTime();
void broadcastTime();
int timeToMinute(String t);
String minuteToTime(int totalMinutes);
void handleLcd();
void updateLcdDisplay();
void handleResetButton();
void initializeNetworkServices();
void startWiFiConnection();
void handleWifiConnection();
void handleOtaCommands(byte* payload, unsigned int length); 
void handleOtaData(byte* payload, unsigned int length);    
#if DEVICE_ROLE == ROLE_MASTER
void setupWebServer();
void webSocketEvent(uint8_t num, WStype_t type, uint8_t *payload, size_t length);
void loadManagedSatellites();
void saveManagedSatellites();
void broadcastSatelliteStatus();
void handleSatelliteDiscovery(byte* payload, unsigned int length);
void handleSatelliteManagement(String topic, byte* payload, unsigned int length);
void updateSatelliteStatus(const char* name, JsonObject statusData);
void publishSystemInfo();
#endif
void setupMusicPlayer();
void handleMusic();
void handleMusicControl(JsonObject payload);
void publishMusicStatus();
void scanMusicFiles();
void playTrackByName(String trackName);
void checkMusicSchedules();
void saveMusicSchedules();
void loadMusicSchedules();
String getTrackNameByIndex(int index);
int getTrackIndexByName(String name);
struct BellAction;
void handleSchedulesAndScenarios();
BellAction findScheduleActionForSession(JsonObject schedule, int currentTimeInMinutes);
BellAction findScenarioAction(int currentTimeInMinutes);
void executeAction(const BellAction& action);
void updateLocalTimeFromEpoch(); 
void showNotification(const char* status, const char* message);
// ====================================================================
// ===================           HTML SETUP          ==================
// ====================================================================
const char SETUP_HTML[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html lang="vi">
<head>
    <title>Thiết lập WiFi</title>
    <meta name="viewport" content="width=device-width,user-scalable=0" charset="utf-8">
    <style>
      body{ background: #222222; font-family: Verdana, sans-serif; color: white; }
      #main{ margin: 10px auto; width: 360px; }
      #content{ border: solid 1px white; width: 360px; float: left; border-radius: 5px; padding: 20px; box-sizing: border-box; }
      h2 { text-align: center; margin-top: 10px; margin-bottom: 25px; }
      .form-group { margin-bottom: 20px; }
      .form-group label { display: block; margin-bottom: 8px; font-size: 16px; }
      .form-group input, .form-group select { width: 100%; padding: 10px; box-sizing: border-box;
      background-color: #333; color: white; border: 1px solid #666; border-radius: 4px; font-size: 1em;
      }
      .form-group .spinner-container { display: flex; align-items: center;
      }
      .form-group .spinner-container select { flex-grow: 1;
      }
      input[type="submit"] { width: 100%; padding: 12px; background-color: #008CBA; color: white; border: none; border-radius: 6px;
      font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px; }
      a { color: cyan; text-decoration: none;
      }
      .status-message { text-align: center; margin-top: 15px; font-weight: bold;
      }
      .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #008CBA; border-radius: 50%; width: 20px;
      height: 20px; animation: spin 1.5s linear infinite; display: none; margin-left: 10px;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg);
      } }
    </style>
</head>
<body>
    <div id="main">
      <div id="content">
        <h2>CÀI ĐẶT WIFI</h2>
        <form id="wifiForm">
            <div class="form-group">
                <label for="ssid">Chọn mạng WiFi:</label>
                <div class="spinner-container">
                  <select id="ssid" name="ssid_sta"></select>
                    <div class="spinner" id="spinner"></div>
                </div>
            </div>
            <div class="form-group">
                <label for="password">Mật khẩu:</label>
                  <input type="password" id="password" name="pass_sta" placeholder="Nhập mật khẩu WiFi...">
            </div>
            <input type="submit" value="Lưu & Khởi động lại">
        </form>
        <p id="status" class="status-message"></p>
        <p style="text-align:center; margin-top:20px;"><a href="/">Quay về trang chủ</a></p>
      </div>
    </div>
    <script>
      function fetchWifiList() {
           const spinner = document.getElementById('spinner');
            const ssidSelect = document.getElementById('ssid');
            spinner.style.display = 'block';
            ssidSelect.disabled = true;
            fetch('/getWifiList')
                .then(response => response.json())
                .then(data => {
                    ssidSelect.innerHTML = '';
                    if (data.ssidList && data.ssidList.length > 0) {
                      data.ssidList.forEach(ssid => {
                            if (ssid) {
                                const option = document.createElement('option');
                                option.value = ssid;
                                option.textContent = ssid;
                                ssidSelect.appendChild(option);
                            }
                        });
                    } else {
                        const option = document.createElement('option');
                        option.textContent = 'Không tìm thấy WiFi nào';
                        ssidSelect.appendChild(option);
                    }
                })
                .catch(error => {
                      console.error('Lỗi khi quét WiFi:', error);
                      const option = document.createElement('option');
                    option.textContent = 'Lỗi khi quét WiFi';
                    ssidSelect.appendChild(option);
                })
                .finally(() => {
                    spinner.style.display = 'none';
                    ssidSelect.disabled = false;
                });
        }
        document.getElementById('wifiForm').addEventListener('submit', function (e) {
            e.preventDefault();
            const status = document.getElementById('status');
            status.textContent = 'Đang lưu cấu hình...';
            const formData = new FormData(this);
            const data = {};
            formData.forEach((value, key) => data[key] = value);
            data['ssid_sta'] = document.getElementById('ssid').value;
            fetch('/saveConfig', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(response => response.text())
            .then(text => {
                status.textContent = text;
                alert(text);
                setTimeout(() => {
                  status.textContent = 'Đang khởi động lại thiết bị...';
                }, 2000);
            })
            .catch(error => {
                console.error('Lỗi khi lưu cấu hình:', error);
                status.textContent = 'Lỗi khi lưu cấu hình.';
            });
        });
        window.onload = fetchWifiList;
    </script>
</body>
</html>
)rawliteral";
#define ROLE_MASTER 1
#define ROLE_SATELLITE 2
#define DEVICE_ROLE ROLE_MASTER

const char* DEVICE_NAME = "ESP32-MayChu";
char ADMIN_PASSWORD[50] = "YenKhanhA@2025";
const char* ADMIN_PASSWORD_FILE = "/admin_password.txt";
// =================== CẤU HÌNH MQTT ===================
char* mqtt_server = "8bdef73996bb4030affe9483eecde31b.s1.eu.hivemq.cloud";
int mqtt_port = 8883;
char* mqtt_username = "ngoctuyka";
char* mqtt_password = "Tu12345678@";
// *** CÁC CHỦ ĐỀ MQTT ĐÃ ĐƯỢỢC CHUẨN HÓA ***
const char* ONLINE_STATUS_TOPIC = "esp32/bell/status/online";
const char* DATA_STATUS_TOPIC = "esp32/bell/data/status";
const char* SET_DATA_TOPIC = "esp32/bell/data/set";
const char* GET_DATA_TOPIC = "esp32/bell/data/get";
const char* CONTROL_TOPIC = "esp32/bell/control";
const char* SYS_INFO_TOPIC = "esp32/bell/status/sysinfo";
const char* SATELLITE_STATUS_TOPIC = "esp32/bell/satellite/status";
const char* MANAGE_STATUS_TOPIC = "esp32/bell/manage/status";
const char* TIME_SYNC_TOPIC = "esp32/bell/time/sync";
const char* COMMAND_ACK_TOPIC = "esp32/bell/command/ack";
const char* OTA_COMMAND_TOPIC = "esp32/bell/ota/command";
const char* OTA_DATA_TOPIC = "esp32/bell/ota/data";
const char* OTA_STATUS_TOPIC = "esp32/bell/ota/status";
const char* OTA_SATELLITE_STATUS_TOPIC = "esp32/bell/ota/satellite/status";
// TOPICS CHO ĐIỀU KHIỂN NHẠC
const char* MUSIC_CONTROL_TOPIC = "esp32/bell/music/control";
const char* MUSIC_STATUS_TOPIC = "esp32/bell/music/status";
// [THÊM MỚI] TOPIC CHO HẸN GIỜ THEO KỊCH BẢN
const char* SCENARIO_SET_TOPIC = "esp32/bell/scenario/set";
const char* SCENARIO_ADD_TOPIC = "esp32/bell/scenario/add";
const char* SCENARIO_DELETE_TOPIC = "esp32/bell/scenario/delete"; // <<< THÊM DÒNG NÀY
const unsigned long TIME_BROADCAST_INTERVAL_MS = 5 * 60 * 1000;
const unsigned long MASTER_TIMEOUT_MS = 10 * 60 * 1000;
#if DEVICE_ROLE == ROLE_MASTER
const char* DISCOVERY_ANNOUNCE_TOPIC = "esp32/bell/discovery/announce";
const char* MANAGE_ADD_TOPIC = "esp32/bell/manage/add";
const char* MANAGE_REMOVE_TOPIC = "esp32/bell/manage/remove";
#endif
WiFiClientSecure espClient;
PubSubClient client(espClient);
// =================== =====================CẤU HÌNH MẠNG ===================
const bool useStaticIP = false;
IPAddress staticIP(192, 168, 1, 101);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(252, 255, 255, 0);
IPAddress dns(8, 8, 8, 8);
// =================== =====================CẤU HÌNH PHẦN CỨNG ===================
const int BUTTON_PIN = 16;
const int relay = 40;
const int MANUAL_BELL_BUTTON_PIN = 18;
const int MANUAL_RING_DURATION = 1100;
const int ledSignal = 2;
const int btSetup = 0;
// Nút reset vật lý
const int RESET_BUTTON_PIN = 17;

// CẤU HÌNH CHO MODULE MP3 DY-SV5W
#define MP3_SERIAL Serial2 // Sử dụng Serial2 cho module MP3
#define MP3_RX_PIN 5     // Chân RX của ESP32-S3 nối với TX của module
#define MP3_TX_PIN 4    // Chân TX của ESP32-S3 nối với RX của module

// ====================================*** CẤU HÌNH LCD & RTC ***===================================
RTC_DS3231 rtc;
bool rtc_available = false;
const int LCD_COLUMNS = 16;
const int LCD_ROWS = 2;
const int LCD_ADDRESS = 0x27;
const unsigned long LCD_TIMEOUT_MS = 120000;
LiquidCrystal_PCF8574 lcd(LCD_ADDRESS);
bool lcd_available = false;
bool isLcdOn = false;
unsigned long lcdTurnOnTime = 0;
bool mp3_available = false; // <<< THÊM DÒNG NÀY
bool showTime = true;
unsigned long lastLcdContentSwitch = 0;
unsigned long lastLcdUpdateTime = 0;
unsigned long lastMqttRetry = 0;
const unsigned long mqttRetryInterval = 30000; // Thử lại MQTT sau mỗi 30 giây
// ====================================== CẤU HÌNH MẠNG & SERVER ===================
#if DEVICE_ROLE == ROLE_MASTER
AsyncWebServer webServer(80);
WebSocketsServer webSocket = WebSocketsServer(81);
#endif
Preferences preferences;
String ssid_sta, pass_sta;
boolean wifiState = false;
String ipAddress = "Dang tim mang...";
bool isInAPMode = false; 
unsigned long lastWifiRetryTime = 0;
const unsigned long wifiRetryInterval = 120000; 
unsigned long lastMqttPublishTime = 0;
const unsigned long mqttPublishInterval = 300000;
unsigned long lastOnlinePing = 0;
const unsigned long onlinePingInterval = 30000;
// ================================================== CẤU HÌNH THỜI GIAN ===================
const char* ntpServer = "vn.pool.ntp.org";
const long gmtOffset_sec = 7 * 3600; // Việt Nam GMT+7
const int daylightOffset_sec = 0;
bool time_is_set = false; // Cờ để biết thời gian đã được thiết lập hay chưa

Ticker ticker;
int gio, phut, giay, thu, ngay, thang, nam;
unsigned long lastNtpSync = 0;
// Đồng bộ mỗi 6 tiếng cho ổn định, có thể đặt lại 15 phút nếu muốn
const unsigned long ntpSyncInterval = 6 * 3600 * 1000; 
// ===================================================== BIẾN TOÀN CỤC ===================
volatile boolean time_to_update_display = false; // <-- THÊM DÒNG NÀY
volatile boolean time_to_check_schedule = false; // <-- THÊM DÒNG NÀY
StaticJsonDocument<3072> allData;
StaticJsonDocument<1024> holidayData;
// Lưu các ngày nghỉ
boolean checkState = 0;
bool networkServicesInitialized = false;
unsigned long lastTimeBroadcast = 0;
bool musicScanned = false; 
StaticJsonDocument<2048> scenarioDoc; 
JsonArray scenarioList;
// DÁN VÀO GẦN CÁC BIẾN JSONDOCUMENT KHÁC (khoảng dòng 67)
StaticJsonDocument<1024> activeZonesDoc; // Lưu danh sách các vệ tinh đang BẬT
JsonArray activeZones;
const char* ACTIVE_ZONES_FILE = "/active_zones.json"; // Tên file để lưu
// ===================================================== BIẾN CHO OTA ===================
bool ota_in_progress = false;
unsigned long ota_start_time = 0;
size_t ota_total_size = 0;
size_t ota_received = 0;
// ====================================================================================
// === ============================================DANH SÁCH VỆ TINH ĐỘNG (JSON) ===
// ====================================================================================
#if DEVICE_ROLE == ROLE_MASTER
StaticJsonDocument<2048> managedSatellitesDoc;
JsonArray managedSatellites;
StaticJsonDocument<2048> discoveredSatellitesDoc;
JsonArray discoveredSatellites;

const char* MANAGED_SATELLITES_FILE = "/managed_satellites.json";
const unsigned long SATELLITE_TIMEOUT_MS = 3.5 * 60 * 1000;
// 3.5 phút
#endif

// ====================================================================================
// [THÊM MỚI] CÁC BIẾN VÀ ĐỐI TƯỢNG CHO TRÌNH PHÁT NHẠC
// ====================================================================================
class DYPlayer_Impl : public DY::DYPlayer {
public:
    void serialWrite(uint8_t *buffer, uint8_t len) override {
        MP3_SERIAL.write(buffer, len);
    }
    bool serialRead(uint8_t *buffer, uint8_t len) override {
        return MP3_SERIAL.readBytes(buffer, len) == len;
    }
};

DYPlayer_Impl player;
StaticJsonDocument<1024> musicStatusDoc;
StaticJsonDocument<1024> musicSchedulesDoc;
JsonArray musicPlaylist;
JsonArray musicSchedules;
unsigned long lastMusicStatusPublish = 0;
const unsigned long musicStatusInterval = 1000;
unsigned long trackStartTime = 0;
uint16_t currentTrackDuration = 0; 

// ====================================================================
// ===================   HÀM setup() VÀ loop()     ====================
// ====================================================================
void setup() {
  pinMode(relay, OUTPUT);
  digitalWrite(relay, LOW);
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n\n--- KHOI DONG THIET BI MAY CHU ---");
  Serial.printf("Ten thiet bi: %s\n", DEVICE_NAME);
  randomSeed(micros());
  pinMode(ledSignal, OUTPUT);
  pinMode(btSetup, INPUT_PULLUP);
  pinMode(MANUAL_BELL_BUTTON_PIN, INPUT_PULLUP);
  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  if(!SPIFFS.begin(true)){
    Serial.println("Lỗi nghiêm trọng: Không thể khởi động bộ nhớ SPIFFS!");
    return;
  }
  
  #if DEVICE_ROLE == ROLE_MASTER
  loadManagedSatellites();
   loadActiveZones(); // <-- THÊM DÒNG NÀY
  loadAdminPassword();
  discoveredSatellites = discoveredSatellitesDoc.to<JsonArray>();
  #endif
  Wire.begin();

  if (rtc.begin()) {
    rtc_available = true;
    Serial.println("Tim thay module RTC DS3231.");
    // [THAY ĐỔI] - Lấy thời gian từ RTC để "mồi" cho hệ thống lúc khởi động
    if (rtc.lostPower()) {
        Serial.println("RTC bi mat nguon, can dong bo NTP!");
    } else {
        Serial.println("-> Lay thoi gian tu RTC de khoi tao he thong.");
        time_t rtc_time = rtc.now().unixtime();
        timeval tv = { rtc_time, 0 };
        settimeofday(&tv, nullptr); // Thiết lập thời gian hệ thống từ RTC
        time_is_set = true;
        Serial.println("-> Da thiet lap thoi gian he thong tu RTC.");
    }
  } else {
    rtc_available = false;
    Serial.println("CANH BAO: Khong tim thay module RTC DS3231!");
  }
  // Khởi tạo màn hình LCD
  Wire.beginTransmission(LCD_ADDRESS);
  if (Wire.endTransmission() == 0) {
    lcd_available = true;
    Serial.println("Tim thay man hinh LCD.");
    lcd.begin(LCD_COLUMNS, LCD_ROWS);
    lcd.setBacklight(HIGH);
    lcd.clear();
    lcd.print(DEVICE_NAME);
    lcd.setCursor(0, 1);
    lcd.print("DANG KHOI DONG...");
    delay(2000);
    isLcdOn = true;
    lcdTurnOnTime = millis();
  } else {
    lcd_available = false;
    Serial.println("CANH BAO: Khong tim thay man hinh LCD!");
  }
  
  // [THÊM MỚI] Khởi tạo trình phát nhạc
  setupMusicPlayer();

  readAllData();
  readHolidayData();
  loadScenarioData(); 
  startWiFiConnection();
  // [SỬA] Phát sóng thời gian cho các vệ tinh định kỳ
    if (client.connected() && time_is_set && (millis() - lastTimeBroadcast > TIME_BROADCAST_INTERVAL_MS)) {
      time_t now_epoch;
      time(&now_epoch);
      String epochStr = String(now_epoch);
      client.publish(TIME_SYNC_TOPIC, epochStr.c_str());
      lastTimeBroadcast = millis();
      Serial.println(">>> (MASTER) Da phat song thoi gian he thong cho cac ve tinh.");
    }
  }
void loop() {
  // --- Xử lý OTA ---
  if (ota_in_progress) {
    if (client.connected()) client.loop();
    delay(1);
    return;
  }

  // --- Quản lý kết nối WiFi ---
  handleWifiConnection();

  // --- Các tác vụ mạng (chỉ chạy khi đã có kết nối) ---
  if (networkServicesInitialized) {
    #if DEVICE_ROLE == ROLE_MASTER
    webSocket.loop();
    #endif

    if (wifiState) {
      // Kết nối lại MQTT nếu mất
      if (!client.connected()) {
        if (millis() - lastMqttRetry > mqttRetryInterval) {
          lastMqttRetry = millis();
          Serial.println("[MQTT] Mat ket noi. Dang thu ket noi lai...");
          reconnectMQTT();
        }
      } else {
        client.loop();
      }
    }

    #if DEVICE_ROLE == ROLE_MASTER
    // Gửi trạng thái hệ thống định kỳ
    if (client.connected() && (millis() - lastMqttPublishTime > mqttPublishInterval)) {
      lastMqttPublishTime = millis();
      publishStateToMqtt();
    }
    // Gửi tín hiệu "online" định kỳ
    if (client.connected() && (millis() - lastOnlinePing > onlinePingInterval)) {
      lastOnlinePing = millis();
      client.publish(ONLINE_STATUS_TOPIC, "online", true);
      Serial.println(">>> (MASTER) Da gui ping 'online' len MQTT.");
    }
    // Kiểm tra timeout của các vệ tinh
    unsigned long now = millis();
    bool statusChanged = false;
    for (JsonObject sat : managedSatellites) {
      if (sat["online"].as<bool>() && (now - sat["lastSeen"].as<unsigned long>() > SATELLITE_TIMEOUT_MS)) {
        sat["online"] = false;
        statusChanged = true;
        Serial.printf("!!! Ve tinh %s da TIMEOUT -> chuyen sang OFFLINE.\n", sat["name"].as<const char*>());
      }
    }
    if (statusChanged) {
      broadcastSatelliteStatus();
    }
    // Phát sóng thời gian cho các vệ tinh định kỳ
    // [SỬA] Phát sóng thời gian cho các vệ tinh định kỳ
    if (client.connected() && time_is_set && (millis() - lastTimeBroadcast > TIME_BROADCAST_INTERVAL_MS)) {
      time_t now_epoch;
      time(&now_epoch);
      String epochStr = String(now_epoch);
      client.publish(TIME_SYNC_TOPIC, epochStr.c_str());
      lastTimeBroadcast = millis();
      Serial.println(">>> (MASTER) Da phat song thoi gian he thong cho cac ve tinh.");
    }
    #endif

    // Xử lý trình phát nhạc và quét file nhạc lần đầu
    handleMusic();
    if (client.connected() && !musicScanned) {
      Serial.println(">>> MQTT da san sang. Bat dau quet danh sach nhac...");
      scanMusicFiles();
      musicScanned = true;
      publishMusicStatus();
    }
  }

  // --- Xử lý các tác vụ được ra hiệu bởi Ticker (1 giây một lần) ---
  if (time_to_update_display) {
    time_to_update_display = false; // Hạ cờ ngay
    updateLcdDisplay();
  }
  if (time_to_check_schedule) {
    time_to_check_schedule = false; // Hạ cờ ngay
    handleSchedulesAndScenarios();
  }
  
  // --- Xử lý phần cứng & giao diện người dùng ---
  handleLcd();
  
  if (digitalRead(MANUAL_BELL_BUTTON_PIN) == LOW) {
    Serial.println("Nut nhan chuong vat ly duoc kich hoat!");
    digitalWrite(relay, HIGH);
    delay(MANUAL_RING_DURATION);
    digitalWrite(relay, LOW);
    delay(200);
  }
  
  // --- Logic đồng bộ NTP (chỉ chạy khi có mạng) ---
  // --- Logic đồng bộ NTP (chỉ chạy khi có mạng) ---
  if (wifiState && networkServicesInitialized) {
    // [THAY ĐỔI] - Logic đồng bộ NTP mới đơn giản hơn
    // Đồng bộ lần đầu tiên hoặc khi đã đến chu kỳ
    if (millis() - lastNtpSync > ntpSyncInterval || (lastNtpSync == 0 && time_is_set == false)) {
        syncTimeWithNTP();
        lastNtpSync = millis();
    }
  }
  
  // --- Khởi động Ticker (chỉ chạy 1 lần khi có thời gian) ---
  if (!ticker.active() && time_is_set) {
    ticker.attach(1, checkTime);
    Serial.println(">>> DA CO THOI GIAN (tu RTC hoac NTP). Khoi dong dong ho he thong (ticker).");
  }

  handleResetButton();
  if (digitalRead(RESET_BUTTON_PIN) == LOW) {
    delay(1000);
    if (digitalRead(RESET_BUTTON_PIN) == LOW) {
      Serial.println("Nút reset được nhấn, đang khởi động lại ESP...");
      ESP.restart();
    }
  }
}

// ====================================================================
// ===================   CÁC HÀM XỬ LÝ NHẠC  ==========================
// ====================================================================
void setupMusicPlayer() {
    MP3_SERIAL.begin(9600, SERIAL_8N1, MP3_RX_PIN, MP3_TX_PIN);
    Serial.println("Khoi tao trinh phat nhac DY-SV5W..."); 
    DY::device_t deviceStatus = player.getPlayingDevice(); //  (Từ DYPlayer.h)
    
    if (deviceStatus < DY::Device::Fail) { 
        Serial.printf("Tim thay module MP3 (phan hoi 'getPlayingDevice' OK). Thiet bi: %d (0=USB, 1=SD, 2=Flash)\n", (uint8_t)deviceStatus);
        mp3_available = true; 
    } else {
        Serial.println("CANH BAO: Khong phan hoi tu module MP3!"); 
        mp3_available = false; 
    }

    // Cấu trúc mặc định cho trạng thái nhạc
    musicStatusDoc["status"] = "stopped"; 
    musicStatusDoc["current_track"] = ""; 
    musicStatusDoc["progress"] = 0; 
    musicStatusDoc["current_time_s"] = 0; 
    musicStatusDoc["total_time_s"] = 0; 
    musicStatusDoc["volume"] = 80; 
    musicStatusDoc["shuffle_mode"] = false; 
    musicStatusDoc["repeat_mode"] = false; 
    musicPlaylist = musicStatusDoc.createNestedArray("playlist"); 
    player.setVolume(25); 
    //scanMusicFiles(); 
    loadMusicSchedules(); 
}

void handleMusic() {
    if (millis() - lastMusicStatusPublish > musicStatusInterval) {
        lastMusicStatusPublish = millis();
        publishMusicStatus();
    }
}
// ====================================================================
// ===================   CÁC HÀM MQTT & KẾT NỐI   ====================
// ====================================================================
#if DEVICE_ROLE == ROLE_MASTER
void publishStateToMqtt() {
  if (!client.connected()) return;

  DynamicJsonDocument doc(4096);
  JsonObject data = doc.createNestedObject("data");

  data["schedule"] = allData;
  data["holidays"] = holidayData;
  data["scenario"] = scenarioDoc; 
  data["epoch"] = time(NULL);

  String dataStr;
  serializeJson(doc, dataStr);
  
  client.publish(DATA_STATUS_TOPIC, dataStr.c_str(), true); 
  Serial.println(">>> (MASTER) Da publish trang thai he thong len MQTT.");
}
#endif
// THAY THẾ TOÀN BỘ HÀM CŨ BẰNG HÀM NÀY
bool connectMQTTWithRetries() {
  if (!wifiState) return false;
  espClient.setInsecure();
  client.setServer(mqtt_server, mqtt_port);
  client.setBufferSize(4096);
  client.setCallback(callback);

  Serial.println("  [MQTT] Thu ket noi 1 lan...");
  String clientId = String(DEVICE_NAME) + "-" + String(random(0xffff), HEX);

  bool connectResult = false;
  #if DEVICE_ROLE == ROLE_MASTER
    const char* lwt_payload = "offline";
    connectResult = client.connect(clientId.c_str(), mqtt_username, mqtt_password, ONLINE_STATUS_TOPIC, 1, true, lwt_payload);
  #else
    // (Giữ nguyên logic cho vai trò SATELLITE nếu có)
  #endif

  if (connectResult) {
    Serial.println("  [MQTT] Ket noi MQTT thanh cong!");
    #if DEVICE_ROLE == ROLE_MASTER
      client.publish(ONLINE_STATUS_TOPIC, "online", true);
      client.subscribe(SET_DATA_TOPIC);
      client.subscribe(CONTROL_TOPIC);
      client.subscribe(GET_DATA_TOPIC);
      client.subscribe(SATELLITE_STATUS_TOPIC);
      client.subscribe(DISCOVERY_ANNOUNCE_TOPIC);
      client.subscribe(MANAGE_ADD_TOPIC);
      client.subscribe(MANAGE_REMOVE_TOPIC);
      client.subscribe(OTA_COMMAND_TOPIC);
      client.subscribe(OTA_DATA_TOPIC);
      client.subscribe(OTA_SATELLITE_STATUS_TOPIC);
      client.subscribe(MUSIC_CONTROL_TOPIC);
      client.subscribe(SCENARIO_SET_TOPIC);
      client.subscribe(SCENARIO_ADD_TOPIC); 
      client.subscribe(SCENARIO_DELETE_TOPIC); 
      broadcastAndPublishState();
      broadcastSatelliteStatus(); 
    #endif
    return true;
  }
  
  Serial.printf("  [MQTT] That bai, rc=%d.\n", client.state());
  return false;
}

void callback(char* topic, byte* payload, unsigned int length) {
  String topicStr = topic;
  Serial.println("\n-----------------------------------------");
  Serial.print("Nhan duoc tin nhan tu topic: ");
  Serial.println(topicStr);
  Serial.print("Payload: ");
  for (unsigned int i = 0; i < length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println("\n-----------------------------------------");
  
 if (topicStr == SCENARIO_SET_TOPIC) {
      Serial.println(">>> NHAN LENH GHI DE KICH BAN (THUONG LA XOA TAT CA).");
      Serial.println("TRANG THAI 'scenarioDoc' TRUOC KHI THAY DOI:");
      serializeJsonPretty(scenarioDoc, Serial);
      Serial.println();
      scenarioDoc.clear();
      DeserializationError error = deserializeJson(scenarioDoc, payload, length);
      if (error) {
          Serial.print("!!! LOI: Parse JSON that bai: ");
          Serial.println(error.c_str());
          scenarioList = scenarioDoc.to<JsonArray>(); 
      } else {
          Serial.println(">>> Parse JSON moi thanh cong.");
          scenarioList = scenarioDoc.as<JsonArray>(); 
      }

      Serial.println("TRANG THAI 'scenarioDoc' SAU KHI GHI DE:");
      serializeJsonPretty(scenarioDoc, Serial);
      Serial.println();
      saveScenarioData();
      Serial.printf(">>> Da goi lenh luu %d su kien.\n", scenarioList.size());
      broadcastAndPublishState(); 
      DynamicJsonDocument ackDoc(128);
      ackDoc["name"] = DEVICE_NAME;
      ackDoc["status"] = "success";
      ackDoc["message"] = "Da GHI DE (Xoa) kịch bản hẹn giờ.";
      String ackPayload;
      serializeJson(ackDoc, ackPayload);
      client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());
      Serial.println(">>> Da hoan tat xu ly va gui ACK.");
      return;
  }
  else if (topicStr == SCENARIO_ADD_TOPIC) {
    Serial.println(">>> Nhan lenh THEM KICH BAN MOI.");
    StaticJsonDocument<512> newScenarioDoc;
    DeserializationError error = deserializeJson(newScenarioDoc, payload, length);
    if (error) {
      Serial.print("!!! LOI: Parse JSON kich ban moi that bai: ");
      Serial.println(error.c_str());
      return;
    }
    
    if (scenarioList.add(newScenarioDoc.as<JsonObject>())) {
      Serial.println(">>> Da them kich ban moi vao danh sach.");
      saveScenarioData();
      broadcastAndPublishState(); 
    } else {
      Serial.println("!!! LOI: Khong du bo nho de them kich ban moi! Hay xoa bot.");
    }
    return;
  }

  else if (topicStr == SCENARIO_DELETE_TOPIC) {
    Serial.println(">>> Nhan lenh XOA MOT KICH BAN.");
    payload[length] = '\0'; 
    int indexToRemove = atoi((char*)payload);
    
    if (indexToRemove >= 0 && indexToRemove < scenarioList.size()) {
        scenarioList.remove(indexToRemove);
        Serial.printf(">>> Da xoa kich ban tai vi tri %d.\n", indexToRemove);
        saveScenarioData(); 
        broadcastAndPublishState(); 
    } else {
        Serial.printf("!!! LOI: Vi tri xoa khong hop le: %d.\n", indexToRemove);
    }
    return;
  }
 
  if (topicStr == MUSIC_CONTROL_TOPIC) {
    StaticJsonDocument<512> doc;
    deserializeJson(doc, payload, length);
    handleMusicControl(doc.as<JsonObject>());
    return;
  }
  
  if (topicStr == OTA_COMMAND_TOPIC) {
    handleOtaCommands(payload, length);
    return;
  }
  if (topicStr == OTA_DATA_TOPIC) {
    handleOtaData(payload, length);
    return;
  }
  
  #if DEVICE_ROLE == ROLE_MASTER
  if (topicStr == OTA_SATELLITE_STATUS_TOPIC) {
    Serial.print("[OTA Vệ Tinh] Nhan duoc trang thai: ");
    for(unsigned int i = 0; i < length; i++) {
      Serial.print((char)payload[i]);
    }
    Serial.println();
    return;
  }
  #endif
  
  #if DEVICE_ROLE == ROLE_MASTER
  if (topicStr == DISCOVERY_ANNOUNCE_TOPIC) {
    handleSatelliteDiscovery(payload, length);
    return;
  }
  if (topicStr == MANAGE_ADD_TOPIC || topicStr == MANAGE_REMOVE_TOPIC) {
    handleSatelliteManagement(topicStr, payload, length);
    return;
  }
  if (topicStr == GET_DATA_TOPIC) {
    Serial.println("Nhan yeu cau cap nhat trang thai tu MQTT client.");
    publishStateToMqtt();
    return;
  }
  #endif

  if (topicStr == SET_DATA_TOPIC) {
    DynamicJsonDocument doc(4096);
    DeserializationError error = deserializeJson(doc, payload, length);
    if (!error) {
        ticker.detach();
        if (doc.containsKey("schedule")) {
            JsonObject newSchedule = doc["schedule"];
            if (newSchedule.containsKey("sohoi")) {
              allData["sohoi"] = newSchedule["sohoi"];
            }
            if (newSchedule.containsKey("lich")) {
              allData["lich"] = newSchedule["lich"];
            }
            saveAllData();
        }
        
        if (doc.containsKey("holidays")) { 
            holidayData = doc["holidays"].as<JsonObject>();
            saveHolidayData(); 
        }

        Serial.println("Nhan du lieu moi tu MQTT, da luu thanh cong.");
        broadcastAndPublishState();

        DynamicJsonDocument ackDoc(128);
        ackDoc["name"] = DEVICE_NAME;
        ackDoc["status"] = "success";
        ackDoc["message"] = "Đã lưu và gửi lịch mới thành công.";
        String ackPayload;
        serializeJson(ackDoc, ackPayload);
        client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());

        if(!ticker.active()) ticker.attach(1, checkTime);
    }
  }

  #if DEVICE_ROLE == ROLE_MASTER
  if (topicStr == CONTROL_TOPIC) {
    DynamicJsonDocument doc(512);
    DeserializationError error = deserializeJson(doc, payload, length);

    if (error) {
        String payloadStr;
        payloadStr.reserve(length);
        for (unsigned int i = 0; i < length; i++) { payloadStr += (char)payload[i];
        }

        if (payloadStr == "GET_SYS_INFO") {
            Serial.println("Nhan lenh GET_SYS_INFO tu web");
            publishSystemInfo();
        }
        return;
    }

    const char* command = doc["command"];
    if (!command) return;

    DynamicJsonDocument ackDoc(256);
    ackDoc["name"] = DEVICE_NAME;

    if (strcmp(command, "TEST_BELL") == 0) {
        Serial.println("Nhan lenh TEST_BELL, may chu tu reo chuong.");
        controlRelay(3); 
        
        ackDoc["status"] = "success";
        ackDoc["message"] = "Đã gửi lệnh thử chuông đến toàn hệ thống.";
        String ackPayload;
        serializeJson(ackDoc, ackPayload);
        client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());
    }
    
    else if (strcmp(command, "TRIGGER_NTP_SYNC") == 0) {
        Serial.println("Nhan lenh dong bo NTP thu cong tu Web.");
        
        // [SỬA] Gọi hàm đồng bộ trước
        syncTimeWithNTP(); 
        
        // Đợi một chút để hàm có thời gian chạy
        delay(100); 

        // Kiểm tra kết quả qua cờ time_is_set
        if (time_is_set) {
            Serial.println("Dong bo NTP thu cong thanh cong.");
            ackDoc["status"] = "success";
            ackDoc["message"] = "Đồng bộ thời gian NTP thành công!";
        } else {
            Serial.println("LOI: Dong bo NTP thu cong that bai.");
            ackDoc["status"] = "error";
            ackDoc["message"] = "Lỗi: Đồng bộ thời gian NTP thất bại!";
        }

        String ackPayload;
        serializeJson(ackDoc, ackPayload);
        client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());
    }
  
  else if (strcmp(command, "MANUAL_SYNC_TIME") == 0) {
      unsigned long newEpoch = doc["epoch"];
      if (newEpoch > 1609459200) { // Mốc thời gian hợp lệ (> 1/1/2021)
          timeval tv = { (time_t)newEpoch, 0 };
          settimeofday(&tv, nullptr); // Đặt thời gian cho hệ thống
          time_is_set = true;

          if (rtc_available) {
              rtc.adjust(DateTime(newEpoch));
              Serial.println(">>> Da cap nhat thoi gian cho DS3231 tu dong bo thu cong!");
          }

          Serial.printf("[TIME] Nhan lenh dong bo thoi gian thu cong. Epoch moi: %lu\n", newEpoch);
          ackDoc["status"] = "success";
          ackDoc["message"] = "Đã đồng bộ thời gian thủ công thành công!";
      } else {
          Serial.println("[TIME] LOI: Nhan duoc epoch khong hop le tu dong bo thu cong.");
          ackDoc["status"] = "error";
          ackDoc["message"] = "Lỗi: Thời gian nhận được không hợp lệ.";
      }

      String ackPayload;
      serializeJson(ackDoc, ackPayload);
      client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());
  }
    else if (strcmp(command, "RESET_WIFI") == 0) {
   
        const char* target = doc["target"];
        if (target && strcmp(target, DEVICE_NAME) == 0) {
            Serial.printf("Nhan lenh RESET_WIFI cho %s\n", target);
            const char* pass = doc["admin_pass"];
            if (pass && strcmp(pass, ADMIN_PASSWORD) == 0) {
                Serial.println("Xac thuc thanh cong. Dang reset...");
                ackDoc["status"] = "success";
                ackDoc["message"] = "Đã xác thực, đang xóa WiFi và khởi động lại...";
                String ackPayload;
                serializeJson(ackDoc, ackPayload);
                client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());
                delay(500);

                preferences.begin("wifi-config", false);
                preferences.clear();
                preferences.end();
                
                delay(1000);
                ESP.restart();
            } else {
                Serial.println("LOI: Sai mat khau quan tri!");
                ackDoc["status"] = "error";
                ackDoc["message"] = "Sai mật khẩu quản trị!";
                String ackPayload;
                serializeJson(ackDoc, ackPayload);
                client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());
            }
        }
    }
    else if (strcmp(command, "RESTART_ESP") == 0) {
        const char* target = doc["target"];
        if (target && strcmp(target, DEVICE_NAME) == 0) {
            Serial.printf("Nhan lenh RESTART_ESP cho %s\n", target);
            const char* pass = doc["admin_pass"];
            if (pass && strcmp(pass, ADMIN_PASSWORD) == 0) {
                Serial.println("Xac thuc thanh cong. Dang khoi dong lai...");
                ackDoc["status"] = "success";
                ackDoc["message"] = "Đã xác thực, thiết bị đang khởi động lại...";
                String ackPayload;
                serializeJson(ackDoc, ackPayload);
                client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());
                delay(1000); 
                ESP.restart();
            } else {
                Serial.println("LOI: Sai mat khau quan tri khi restart!");
                ackDoc["status"] = "error";
                ackDoc["message"] = "Sai mật khẩu quản trị!";
                String ackPayload;
                serializeJson(ackDoc, ackPayload);
                client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());
            }
        }
    }
    else if (strcmp(command, "CHANGE_PASSWORD") == 0) {
        Serial.println("Nhan lenh CHANGE_PASSWORD");
        const char* old_pass = doc["old_pass"];
        const char* new_pass = doc["new_pass"];
        if (old_pass && new_pass) {
            if (strcmp(old_pass, ADMIN_PASSWORD) == 0) {
                strncpy(ADMIN_PASSWORD, new_pass, sizeof(ADMIN_PASSWORD) - 1);
                ADMIN_PASSWORD[sizeof(ADMIN_PASSWORD) - 1] = '\0';
                saveAdminPassword();
                
                Serial.println("Mat khau da duoc thay doi thanh cong.");
                ackDoc["status"] = "success";
                ackDoc["message"] = "Mật khẩu đã được thay đổi thành công!";

                DynamicJsonDocument syncDoc(128);
                syncDoc["command"] = "FORCE_CHANGE_PASSWORD";
                syncDoc["new_pass"] = new_pass;
                String syncPayload;
                serializeJson(syncDoc, syncPayload);
                client.publish(CONTROL_TOPIC, syncPayload.c_str());
                Serial.println(">>> Da gui lenh dong bo mat khau den cac ve tinh.");
            } else {
                Serial.println("LOI: Sai mat khau cu!");
                ackDoc["status"] = "error";
                ackDoc["message"] = "Sai mật khẩu cũ!";
            }
        } else {
            Serial.println("LOI: Thieu thong tin mat khau trong lenh.");
            ackDoc["status"] = "error";
            ackDoc["message"] = "Lệnh không hợp lệ, thiếu thông tin.";
        }
        String ackPayload;
        serializeJson(ackDoc, ackPayload);
        client.publish(COMMAND_ACK_TOPIC, ackPayload.c_str());
    }
  }

  if (topicStr == SATELLITE_STATUS_TOPIC) {
      DynamicJsonDocument doc(256);
      DeserializationError error = deserializeJson(doc, payload, length);
      if (error) return;

      const char* name = doc["name"];
      if (name) {
          JsonObject data = doc.as<JsonObject>();
          updateSatelliteStatus(name, data);
      }
  }
  #endif
}
// ====================================================================
// ===================   [THÊM MỚI] CÁC HÀM CHO KỊCH BẢN HẸN GIỜ  =======
// ====================================================================
struct BellAction {
  String action = "none"; 
  int numBells = 0;
  String trackName = "";
  int volume = 25;
  bool isRandom = false;
  bool isValid = false;
  String priority = "none"; 
};

// THAY THẾ TOÀN BỘ HÀM executeAction CŨ BẰNG HÀM NÀY
void executeAction(const BellAction& action) {
  if (!action.isValid) return;

  Serial.println(">>> THUC THI HANH DONG THEO LICH: " + action.action);
  
  // 1. Máy chủ luôn luôn thực hiện hành động
  Serial.println("--> May Chu thuc thi lenh cuc bo.");
  if (action.action == "bell") {
    controlRelay(action.numBells);
  } else if (action.action == "music") {
    String trackToPlay = action.trackName;
    if (action.isRandom && musicPlaylist.size() > 0) {
      int randomIndex = random((long)musicPlaylist.size());
      trackToPlay = musicPlaylist[randomIndex].as<String>();
    }
    if (!trackToPlay.isEmpty()) {
      player.setVolume(action.volume);
      playTrackByName(trackToPlay);
    }
  }

  // 2. Gửi lệnh tới các vệ tinh đang được BẬT
  if (activeZones.size() > 0) {
    Serial.printf("--> Gui lenh den %d ve tinh dang hoat dong...\n", activeZones.size());

    // Tạo payload lệnh
    DynamicJsonDocument doc(256);
    if (action.action == "bell") {
      doc["command"] = "SCHEDULED_BELL";
      doc["num"] = action.numBells;
    } else if (action.action == "music") {
      // Lưu ý: Vệ tinh cũng cần có file nhạc tương ứng
      doc["command"] = "SCHEDULED_MUSIC";
      doc["track"] = action.trackName;
      doc["volume"] = action.volume;
      doc["random"] = action.isRandom;
    }

    // Lặp qua danh sách và gửi lệnh
    for (JsonVariant satelliteName : activeZones) {
      doc["target"] = satelliteName.as<String>();
      String payload;
      serializeJson(doc, payload);
      client.publish(CONTROL_TOPIC, payload.c_str());
      Serial.printf("    - Da gui lenh toi: %s\n", satelliteName.as<const char*>());
      delay(20); // Thêm một độ trễ nhỏ để tránh quá tải
    }
  } else {
    Serial.println("--> Khong co ve tinh nao duoc kich hoat.");
  }
}

BellAction findScenarioAction(int currentTimeInMinutes) {
  BellAction action; // Mặc định isValid = false
  if (scenarioList.isNull() || scenarioList.size() == 0) {
    return action;
  }

  String dayKey;
  switch(thu) {
    case 1: dayKey = "t2"; break;
    case 2: dayKey = "t3"; break;
    case 3: dayKey = "t4"; break;
    case 4: dayKey = "t5"; break;
    case 5: dayKey = "t6"; break;
    case 6: dayKey = "t7"; break;
    case 0: dayKey = "cn"; break;
    default: return action;
  }

  for (JsonObject scenarioObject : scenarioList) {
    
    JsonArray scenarioDays = scenarioObject["days"];
    if (scenarioDays.isNull()) continue; 

    bool todayIsActive = false;
    for (JsonVariant day : scenarioDays) {
      if (day.as<String>() == dayKey) {
        todayIsActive = true;
        break;
      }
    }

    if (!todayIsActive) {
      continue;
    }

    JsonArray scenarioEvents = scenarioObject["scenario"];
    if (scenarioEvents.isNull()) continue; // Bỏ qua nếu kịch bản không có sự kiện

    for (JsonObject event : scenarioEvents) {
      int eventTime = timeToMinute(event["time"].as<String>());
      if (eventTime == currentTimeInMinutes) {
        action.action = "bell";
        action.numBells = event["bell"] | 0;
        action.isValid = true;
        action.priority = scenarioObject["priority"] | "none"; 
        Serial.println("Tim thay su kien KICH BAN khop thoi gian.");
        return action; 
      }
    }
  }
  
  return action; 
}

BellAction findScheduleActionForSession(JsonObject schedule, int currentTimeInMinutes) {
  BellAction action;
  bool isEnabled = schedule["enabled"] | false;
  if (!isEnabled) return action;
  bool has_special_event = schedule["has_special_event"] | false;
  bool has_duvao_bell = schedule["has_duvao_bell"] | true;
  int startTime = timeToMinute(schedule["gio"].as<String>());
  String lessonTime_str = schedule["tiethoc"] | "45";
  String rachoi_str = schedule["rachoi"] | "5";
  int prepareTime = has_duvao_bell ? (schedule["duvaotiet"] | 3) : 0;
  int numLessons = schedule["sotiet"];
  int specialEventTime = has_special_event ? (schedule["chaoco"] | schedule["chunhiem"] | 0) : 0;
  int specialPrepareTime = has_special_event ? (schedule["prepare_after_special"] | 2) : 0;

  if (startTime == 0 || numLessons == 0) return action;
  int breakTimes[10];
  int breakCount = 0;
  int lastIndex = 0;
  for (int i = 0; i < rachoi_str.length() && breakCount < 10; i++) {
    if (rachoi_str.charAt(i) == ',') {
      breakTimes[breakCount++] = rachoi_str.substring(lastIndex, i).toInt();
      lastIndex = i + 1;
    }
  }
  breakTimes[breakCount++] = rachoi_str.substring(lastIndex).toInt();

  int lessonTimes[10];
  int lessonCountParsed = 0;
  int lastIndexLesson = 0;
  for (int i = 0; i < lessonTime_str.length() && lessonCountParsed < 10; i++) {
    if (lessonTime_str.charAt(i) == ',') {
      lessonTimes[lessonCountParsed++] = lessonTime_str.substring(lastIndexLesson, i).toInt();
      lastIndexLesson = i + 1;
    }
  }
  lessonTimes[lessonCountParsed++] = lessonTime_str.substring(lastIndexLesson).toInt();
 
  struct BellEvent { int time; String bellType; };
  BellEvent events[40];
  int eventCount = 0;
  int currentTime = startTime;

  if (has_special_event && specialEventTime > 0) {
    events[eventCount++] = {currentTime, "batdau"};
    currentTime += specialEventTime;
    if (specialPrepareTime > 0) {
      events[eventCount++] = {currentTime, "duvao"};
      currentTime += specialPrepareTime;
    }
  } else {
    events[eventCount++] = {currentTime, "batdau"};
  }

  for (int i = 1; i <= numLessons; i++) {
    int currentLessonTime = (i - 1 < lessonCountParsed) ? lessonTimes[i - 1] : lessonTimes[lessonCountParsed - 1];
    events[eventCount++] = {currentTime, "vaotiet"};
    currentTime += currentLessonTime; // Sử dụng thời gian đã lấy

    if (i < numLessons) {
      int currentBreakTime = (i - 1 < breakCount) ? breakTimes[i - 1] : breakTimes[breakCount - 1];
      if (currentBreakTime > 0) {
        events[eventCount++] = {currentTime, "rachoi"};
        currentTime += currentBreakTime;
        if (prepareTime > 0) {
          events[eventCount++] = {currentTime, "duvao"};
          currentTime += prepareTime;
        }
      }
    }
  }

  events[eventCount++] = {currentTime, "rachoi"};
    for (int i = 0; i < eventCount; i++) {
    if (events[i].time == currentTimeInMinutes) {
      String bellType = events[i].bellType;
      JsonObject bellSettings = allData["sohoi"][bellType];
      if (bellSettings.isNull()) {
        Serial.printf("Khong tim thay cai dat cho kieu chuong: %s\n", bellType.c_str());
        continue;
      }

      action.action = bellSettings["action"] | "bell";
      action.numBells = bellSettings["num"] | 0;
      action.trackName = bellSettings["track"].as<String>();
      action.volume = bellSettings["volume"] | 25;
      action.isRandom = bellSettings["random"] | false;
      action.isValid = true;
      action.priority = "schedule";
      Serial.println("Tim thay su kien LICH HOC khop thoi gian.");
      return action;
    }
  }
  return action;
}

void handleSchedulesAndScenarios() {
  int currentTimeInMinutes = gio * 60 + phut;
  String dayKey;
  switch(thu) {
    case 1: dayKey = "t2"; break;
    case 2: dayKey = "t3"; break;
    case 3: dayKey = "t4"; break;
    case 4: dayKey = "t5"; break;
    case 5: dayKey = "t6"; break;
    case 6: dayKey = "t7"; break;
    case 0: dayKey = "cn"; break;
    default: return; 
  }

  BellAction scheduleAction;
  JsonObject sang_sched = allData["lich"]["sang"][dayKey];
  if (!sang_sched.isNull()) {
      scheduleAction = findScheduleActionForSession(sang_sched, currentTimeInMinutes);
  }
  if (!scheduleAction.isValid) { // Nếu buổi sáng không có gì, kiểm tra buổi chiều
      JsonObject chieu_sched = allData["lich"]["chieu"][dayKey];
      if (!chieu_sched.isNull()) {
          scheduleAction = findScheduleActionForSession(chieu_sched, currentTimeInMinutes);
      }
  }

  BellAction scenarioAction = findScenarioAction(currentTimeInMinutes);
  if (scheduleAction.isValid && scenarioAction.isValid) {
     Serial.printf("!!! XUNG DOT giua Lich Hoc (priority: %s) va Kich Ban (priority: %s)\n", scheduleAction.priority.c_str(), scenarioAction.priority.c_str());
      if (scenarioAction.priority == "scenario") {
        Serial.println(">>> Uu tien KICH BAN.");
        executeAction(scenarioAction);
    } else {
        Serial.println(">>> Uu tien LICH HOC.");
        executeAction(scheduleAction);
    }
  } else if (scheduleAction.isValid) {
    executeAction(scheduleAction);
  } else if (scenarioAction.isValid) {
    executeAction(scenarioAction);
  }
}

// ====================================================================
// ===================   CÁC HÀM CŨ (GIỮ NGUYÊN)   =====================
// ====================================================================

void publishOtaStatus(const char* status, const char* details) {
  if (client.connected()) {
    StaticJsonDocument<256> doc;
    doc["device"] = DEVICE_NAME;
    doc["status"] = status;
    doc["details"] = details;
    String output;
    serializeJson(doc, output);
    client.publish(OTA_STATUS_TOPIC, output.c_str());
  }
  Serial.printf("[OTA] Status: %s - Details: %s\n", status, details);
}

String formatUptime(unsigned long uptime_ms) {
    if (uptime_ms == 0) return "N/A";
    unsigned long seconds = uptime_ms / 1000;
    int days = seconds / 86400;
    seconds %= 86400;
    int hours = seconds / 3600;
    seconds %= 3600;
    int minutes = seconds / 60;

    String result = "";
    if (days > 0) {
        result += String(days) + "d ";
    }
    if (hours > 0 || days > 0) {
        result += String(hours) + "h ";
    }
    result += String(minutes) + "m";
    return result;
}

void turnOnLcdAndResetTimeout() {
    if (lcd_available && !isLcdOn) {
        isLcdOn = true;
        lcd.setBacklight(HIGH);
        Serial.println("LCD bat bang lenh tu xa.");
    }
    lcdTurnOnTime = millis();
}

#if DEVICE_ROLE == ROLE_MASTER

void broadcastAndPublishState() {
  Serial.println(">>> (MASTER) Dang broadcast va publish trang thai he thong...");
  if (webSocket.connectedClients() > 0) {
    DynamicJsonDocument doc(4096);
    doc["type"] = "schedule_update"; 
    doc["data"]["schedule"] = allData;
    doc["data"]["holidays"] = holidayData;
    doc["data"]["scenario"] = scenarioDoc;
    doc["data"]["epoch"] = time(NULL);

    String wsDataStr;
    serializeJson(doc, wsDataStr);
    webSocket.broadcastTXT(wsDataStr);
    Serial.println("    -> Da broadcast den cac client LAN.");
  }

   publishStateToMqtt(); 
}

void publishSystemInfo() {
    if (client.connected()) {
        DynamicJsonDocument doc(2048);
        doc["ssid"] = WiFi.SSID();
        doc["ip"] = WiFi.localIP().toString();
        doc["rtc"] = rtc_available;
        doc["lcd"] = lcd_available;
        doc["mp3"] = mp3_available; 
        const esp_partition_t* running_partition = esp_ota_get_running_partition();
        if (running_partition != NULL) {
          doc["flash_usage"] = String(((float)ESP.getSketchSize() / (float)running_partition->size) * 100.0, 1);
          doc["running_partition"] = String(running_partition->label);
        } else {
          doc["flash_usage"] = "N/A";
          doc["running_partition"] = "N/A";
        }
        
        float sram_usage = (float)(ESP.getHeapSize() - ESP.getFreeHeap()) / (float)ESP.getHeapSize() * 100.0;
        doc["sram_usage_percent"] = String(sram_usage, 1);
        doc["sram_free_kb"] = String(ESP.getFreeHeap() / 1024.0, 1);
        if (psramFound()) {
          float psram_usage = (float)(ESP.getPsramSize() - ESP.getFreePsram()) / (float)ESP.getPsramSize() * 100.0;
          doc["psram_usage_percent"] = String(psram_usage, 1);
          doc["psram_free_mb"] = String(ESP.getFreePsram() / 1024.0 / 1024.0, 2);
        } else {
          doc["psram_usage_percent"] = "N/A";
          doc["psram_free_mb"] = "N/A";
        }
        
        doc["satellites"] = managedSatellites;
        String output;
        serializeJson(doc, output);
        client.publish(SYS_INFO_TOPIC, output.c_str());
        Serial.println(">>> (MASTER) Da gui thong tin he thong len MQTT.");
    }
}
#endif

void handleWifiConnection() {
  if (isInAPMode) return; 

  // [FIX] Logic mới để xử lý việc kết nối lại
  if (WiFi.status() == WL_CONNECTED) {
    // Nếu đã kết nối WiFi nhưng các dịch vụ mạng chưa được khởi tạo
    if (!networkServicesInitialized) {
        Serial.println("\n[RECONNECT] Phat hien da ket noi lai WiFi, dang khoi tao lai dich vu mang...");
        initializeNetworkServices(); // Khởi tạo lại WebServer, WebSocket, v.v.
        
        // Cố gắng kết nối MQTT ngay lập tức thay vì chờ vòng lặp tiếp theo
        if (!client.connected()) {
            reconnectMQTT();
        }
    }
    return; // Đã kết nối và dịch vụ đã chạy, không cần làm gì thêm
  }

  // Logic xử lý khi mất kết nối (giữ nguyên)
  if (wifiState) {
    wifiState = false;
    networkServicesInitialized = false; // Đặt lại cờ này là đúng
    ipAddress = "Mat ket noi...";
    Serial.println("\nMat ket noi WiFi!");
  }

  // Logic thử kết nối lại WiFi sau một khoảng thời gian (giữ nguyên)
  if (millis() - lastWifiRetryTime > wifiRetryInterval) {
    lastWifiRetryTime = millis();
    if (ssid_sta != "") {
      Serial.println("Dang thu ket noi lai WiFi...");
      ipAddress = "Dang ket noi...";
      WiFi.begin(ssid_sta.c_str(), pass_sta.c_str());
    }
  }
}

void updateLcdDisplay() {
  if(!lcd_available) return;
  if (ota_in_progress) {
    return;
  }

  lcd.setCursor(0, 0);
  lcd.print("IP:" + ipAddress + "  ");

  lcd.setCursor(0, 1);
  if(showTime) {
    char timeBuffer[17];
    sprintf(timeBuffer, "Gio: %02d:%02d:%02d  ", gio, phut, giay);
    lcd.print(timeBuffer);
  } else {
    char dateBuffer[17];
    sprintf(dateBuffer, "Ngay:%02d/%02d/%04d", ngay, thang, nam);
    lcd.print(dateBuffer);
  }
}

void handleLcd() {
  if(!lcd_available) return;
  int reading = digitalRead(BUTTON_PIN);
  if (reading == LOW) {
    if (!isLcdOn) {
        isLcdOn = true;
        lcd.setBacklight(HIGH);
        Serial.println("LCD bat bang nut nhan.");
    }
    lcdTurnOnTime = millis();
  }
  if (millis() - lastLcdContentSwitch > 5000) {
        lastLcdContentSwitch = millis();
        showTime = !showTime;
      }
  if (isLcdOn) {
    if (millis() - lcdTurnOnTime > LCD_TIMEOUT_MS && !ota_in_progress) {
      isLcdOn = false;
      lcd.setBacklight(LOW);
     //lcd.clear();
      Serial.println("LCD da tu dong tat den nen.");
      }
    }
  }

void initializeNetworkServices() {
    Serial.println("WiFi da san sang. Khoi tao cac dich vu mang (NON-BLOCKING)...");
    
    #if DEVICE_ROLE == ROLE_MASTER
    setupWebServer();
    webSocket.begin();
    webSocket.onEvent(webSocketEvent);
    #endif

    Serial.println("\n-------------- DICH VU MANG (HTTP/WS) SAN SANG -------------");
    networkServicesInitialized = true;
}
    
// [THAY ĐỔI] - Hàm đồng bộ NTP được viết lại hoàn toàn theo đề xuất
void syncTimeWithNTP() {
  if (!wifiState) return;

  Serial.println("[NTP] Bat dau dong bo thoi gian...");
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

  struct tm timeinfo;
  if (getLocalTime(&timeinfo, 10000)) { // Thêm timeout 10 giây
    time_is_set = true;
    Serial.printf(">>> [NTP] Dong bo thanh cong. Thoi gian hien tai: %02d/%02d/%04d %02d:%02d:%02d\n",
                  timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900,
                  timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
    
    // Cập nhật lại các biến thời gian toàn cục ngay lập tức
    checkTime(); 
    
    // Cập nhật thời gian vào module RTC DS3231 để dự phòng
    if (rtc_available) {
        time_t now;
        time(&now);
        rtc.adjust(DateTime(now));
        Serial.println(">>> Da cap nhat thoi gian tu NTP vao module RTC DS3231.");
    }
  } else {
    Serial.println("!!! [NTP] LOI: Khong the lay thoi gian tu server sau 10 giay.");
  }
}

void reconnectMQTT() {
  if(!wifiState || client.connected()) return;
  Serial.println("Mat ket noi MQTT. Dang thu ket noi lai...");
  connectMQTTWithRetries();
}

void handleMusicControl(JsonObject payload) {
    String command = payload["command"].as<String>();
    Serial.print("Nhan lenh dieu khien nhac: ");
    Serial.println(command);
    if (command == "play_pause") {
        DY::play_state_t state = player.checkPlayState();
        if (state == DY::PlayState::Playing) {
            player.pause();
        } else {
            player.play();
        }
    } else if (command == "next") {
        player.next();
    } else if (command == "prev") {
        player.previous();
    } else if (command == "play_track") {
        String trackName = payload["value"].as<String>();
        playTrackByName(trackName);
    } else if (command == "set_volume") {
        int volume100 = payload["value"].as<int>();
        int volume30 = map(volume100, 0, 100, 0, 30);
        player.setVolume(volume30);
        musicStatusDoc["volume"] = volume100;
    } else if (command == "seek") {
        Serial.println("CANH BAO: Chuc nang 'seek' (tua) khong duoc ho tro boi thu vien nay.");
    } else if (command == "toggle_shuffle") {
        bool shuffle = !musicStatusDoc["shuffle_mode"].as<bool>();
        musicStatusDoc["shuffle_mode"] = shuffle;
        if (shuffle) {
            player.setCycleMode(DY::PlayMode::Random);
        } else {
            if (!musicStatusDoc["repeat_mode"].as<bool>()) {
                 player.setCycleMode(DY::PlayMode::Sequence);
            }
        }
    } else if (command == "toggle_repeat") {
        bool repeat = !musicStatusDoc["repeat_mode"].as<bool>();
        musicStatusDoc["repeat_mode"] = repeat;
        if (repeat) {
            player.setCycleMode(DY::PlayMode::Repeat);
        } else {
            if (!musicStatusDoc["shuffle_mode"].as<bool>()) {
                 player.setCycleMode(DY::PlayMode::Sequence);
            }
        }
    } else if (command == "schedule_add") {
        JsonObject schedule = payload["value"];
        musicSchedules.add(schedule);
        saveMusicSchedules();
    } else if (command == "schedule_remove") {
        int index = payload["value"].as<int>();
        if (index >= 0 && index < musicSchedules.size()) {
            musicSchedules.remove(index);
            saveMusicSchedules();
        }
    }
    
    publishMusicStatus();
}

void publishMusicStatus() {
  if (!mp3_available) {
        // Nếu module MP3 không có sẵn, chỉ cập nhật trạng thái "stopped"
        // mà không gọi hàm player.checkPlayState()
        musicStatusDoc["status"] = "stopped";
        musicStatusDoc["current_track"] = "";
        musicStatusDoc["current_time_s"] = 0;
    } 
    else {
        DY::play_state_t state = player.checkPlayState(); 
        switch (state) {
            case DY::PlayState::Playing: musicStatusDoc["status"] = "playing"; break; 
            case DY::PlayState::Paused: musicStatusDoc["status"] = "paused"; break; 
            default: musicStatusDoc["status"] = "stopped"; break; 
        }
        int currentTrackNum = player.getPlayingSound(); 
        musicStatusDoc["current_track"] = getTrackNameByIndex(currentTrackNum);
        if (musicStatusDoc["status"] == "playing") {
          musicStatusDoc["current_time_s"] = (millis() - trackStartTime) / 1000; 
        }
    } 

      if (client.connected()) {
        String output;
        serializeJson(musicStatusDoc, output);
        client.publish(MUSIC_STATUS_TOPIC, output.c_str());
    }

     if (webSocket.connectedClients() > 0) {
      DynamicJsonDocument doc(2048); 
      doc["type"] = "music_status"; 
      JsonObject data = doc.to<JsonObject>();
      data.set(musicStatusDoc.as<JsonObject>());
      String wsOutput;
      serializeJson(doc, wsOutput);
      webSocket.broadcastTXT(wsOutput); 
    }
}
void scanMusicFiles() {
    musicPlaylist.clear();
    File root = SPIFFS.open("/music");
    if(!root || !root.isDirectory()){
        Serial.println("LOI: Khong tim thay thu muc /music. Vui long tao va tai file nhac len.");
        return;
    }

    File file = root.openNextFile();
    while(file){
        if(!file.isDirectory()){
            String fileName = String(file.name());
            if (fileName.endsWith(".mp3")) {
                musicPlaylist.add(fileName.substring(fileName.lastIndexOf('/') + 1));
            }
        }
        file = root.openNextFile();
    }
    Serial.printf("Da quet xong, tim thay %d file nhac.\n", musicPlaylist.size());
}

void playTrackByName(String trackName) {
    int trackIndex = getTrackIndexByName(trackName);
    if (trackIndex != -1) {
        player.playSpecified(trackIndex + 1);
        trackStartTime = millis();
        musicStatusDoc["current_time_s"] = 0;
    } else {
        Serial.printf("LOI: Khong tim thay bai hat ten '%s' trong danh sach.\n", trackName.c_str());
    }
}

String getTrackNameByIndex(int index) {
    if (index > 0 && index <= musicPlaylist.size()) {
        return musicPlaylist[index - 1].as<String>();
    }
    return "";
}

int getTrackIndexByName(String name) {
    for (int i = 0; i < musicPlaylist.size(); i++) {
        if (musicPlaylist[i].as<String>() == name) {
            return i;
        }
    }
    return -1;
}

void checkMusicSchedules() {
    char currentTimeStr[6];
    sprintf(currentTimeStr, "%02d:%02d", gio, phut);
    
    String dayKey;
    switch(thu) {
      case 1: dayKey = "t2"; break;
      case 2: dayKey = "t3"; break;
      case 3: dayKey = "t4"; break; case 4: dayKey = "t5"; break;
      case 5: dayKey = "t6"; break;
      case 6: dayKey = "t7"; break;
      case 0: dayKey = "cn"; break;
    }

    for (JsonObject schedule : musicSchedules) {
        if (schedule["time"].as<String>() == currentTimeStr) {
            JsonArray days = schedule["days"];
            for (String day : days) {
                if (day == dayKey) {
                    String trackToPlay = schedule["track_name"].as<String>();
                    Serial.printf("HEN GIO: Phat bai '%s' theo lich.\n", trackToPlay.c_str());
                    playTrackByName(trackToPlay);
                    break;
                }
            }
        }
    }
}

void saveMusicSchedules() {
    preferences.begin("music-schedules", false);
    String dataStr;
    serializeJson(musicSchedulesDoc, dataStr);
    preferences.putString("schedules", dataStr);
    preferences.end();
    Serial.println("-> Da luu lich hen gio phat nhac.");
}

void loadMusicSchedules() {
    preferences.begin("music-schedules", true);
    String dataStr = preferences.getString("schedules", "[]");
    preferences.end();

    DeserializationError error = deserializeJson(musicSchedulesDoc, dataStr);
    if (error) {
        Serial.println("LOI: Khong the doc lich hen gio, tao danh sach rong.");
        musicSchedules = musicSchedulesDoc.to<JsonArray>();
    } else {
        musicSchedules = musicSchedulesDoc.as<JsonArray>();
        Serial.printf("Da tai %d lich hen gio phat nhac.\n", musicSchedules.size());
    }
    musicStatusDoc["schedules"] = musicSchedules;
}

void handleOtaCommands(byte* payload, unsigned int length) {
    StaticJsonDocument<256> doc;
    deserializeJson(doc, payload, length);
    String action = doc["action"];
    if (action == "START") {
        ota_total_size = doc["size"];
        ota_received = 0;
        ota_start_time = millis();
        ota_in_progress = true;

        if (lcd_available) {
            isLcdOn = true;
            lcdTurnOnTime = millis(); 
            lcd.setBacklight(HIGH);
            lcd.clear();
            lcd.setCursor(0, 0);
            lcd.print("DANG CAP NHAT...");
            lcd.setCursor(0, 1); lcd.print("Bat dau...");
        }
        
        Serial.printf("[OTA] Bat dau qua trinh cap nhat. Tong dung luong: %u bytes\n", ota_total_size);
        if (!Update.begin(ota_total_size)) {
            String errorMsg = "Khong du bo nho. Error: " + String(Update.getError());
            publishOtaStatus("error", errorMsg.c_str());
            ota_in_progress = false;
        } else {
            publishOtaStatus("start", "Bat dau nhan du lieu...");
        }
    } else if (action == "END") {
        if (Update.end(true)) {
            publishOtaStatus("success", "Cap nhat thanh cong! Dang khoi dong lai...");
            if(lcd_available){
              lcd.clear();
              lcd.setCursor(0,0); lcd.print("CAP NHAT XONG!");
              lcd.setCursor(0,1);
              lcd.print("Khoi dong lai...");
            }
            delay(2000);
            ESP.restart();
        } else {
            String errorMsg = "Loi xac thuc. Error: " + String(Update.getError());
            publishOtaStatus("error", errorMsg.c_str());
            if(lcd_available){
              lcd.clear();
              lcd.setCursor(0,0); lcd.print("LOI OTA!");
            }
            ota_in_progress = false;
        }
    } else if (action == "CANCEL") {
        Update.abort();
        publishOtaStatus("cancelled", "Da huy bo qua trinh cap nhat.");
        ota_in_progress = false;
    }
}

void loadMqttConfig() {
  preferences.begin("mqtt-config", true);
  String server = preferences.getString("server", mqtt_server);
  String user = preferences.getString("user", mqtt_username);
  String pass = preferences.getString("pass", mqtt_password);
  
  strncpy(mqtt_server, server.c_str(), sizeof(mqtt_server) - 1);
  strncpy(mqtt_username, user.c_str(), sizeof(mqtt_username) - 1);
  strncpy(mqtt_password, pass.c_str(), sizeof(mqtt_password) - 1);
  
  mqtt_port = preferences.getInt("port", mqtt_port);
  
  preferences.end();
  Serial.println("-> Da tai cau hinh MQTT tu Preferences.");
}

void saveMqttConfig(const char* server, int port, const char* user, const char* pass) {
  preferences.begin("mqtt-config", false);
  preferences.putString("server", server);
  preferences.putInt("port", port);
  preferences.putString("user", user);
  preferences.putString("pass", pass);
  preferences.end();
  Serial.println("-> Da luu cau hinh MQTT vao Preferences.");
}

void handleOtaData(byte* payload, unsigned int length) {
    if (!ota_in_progress) return;
    if (Update.write(payload, length) != length) {
        String errorMsg = "Loi ghi du lieu. Error: " + String(Update.getError());
        publishOtaStatus("error", errorMsg.c_str());
        ota_in_progress = false;
        return;
    }

    ota_received += length;
    static unsigned long last_report_time = 0;
    if (millis() - last_report_time > 500 || ota_received == ota_total_size) {
        last_report_time = millis();
        int percent = (ota_received * 100) / ota_total_size;

        float elapsed_s = (millis() - ota_start_time) / 1000.0;
        float speed_kbs = (ota_received / 1024.0) / (elapsed_s > 0 ? elapsed_s : 1);
      
        char status_msg[128];
        sprintf(status_msg, "{\"status\":\"progress\", \"progress\":%d, \"details\":\"Dang cap nhat... %.1f KB/s\"}", percent, speed_kbs);
        client.publish(OTA_STATUS_TOPIC, status_msg);
        if (lcd_available) {
            char line[20];
            sprintf(line, "  %3d%%   %5.1fKB/s", percent, speed_kbs);
            lcd.setCursor(0, 1);
            lcd.print(line);
        }
    }
}
#if DEVICE_ROLE == ROLE_MASTER
void saveAdminPassword() {
  File file = SPIFFS.open(ADMIN_PASSWORD_FILE, "w");
  if (!file) {
    Serial.println("LOI: Khong the mo file de luu mat khau!");
    return;
  }
  file.print(ADMIN_PASSWORD);
  file.close();
  Serial.println("-> Da luu mat khau quan tri vao SPIFFS.");
}

void loadAdminPassword() {
  if (SPIFFS.exists(ADMIN_PASSWORD_FILE)) {
    File file = SPIFFS.open(ADMIN_PASSWORD_FILE, "r");
    if (file) {
      String pass = file.readString();
      pass.trim();
      strncpy(ADMIN_PASSWORD, pass.c_str(), sizeof(ADMIN_PASSWORD) - 1);
      ADMIN_PASSWORD[sizeof(ADMIN_PASSWORD) - 1] = '\0';
      file.close();
      Serial.println("Da tai mat khau quan tri tu SPIFFS.");
    } else {
      Serial.println("LOI: Khong the doc file mat khau, su dung mat khau mac dinh.");
    }
  } else {
    Serial.println("Khong tim thay file mat khau, tao moi voi mat khau mac dinh.");
    saveAdminPassword();
  }
}

void loadManagedSatellites() {
  File file = SPIFFS.open(MANAGED_SATELLITES_FILE, "r");
  if (!file) {
    Serial.println("Khong tim thay file luu ve tinh, se tao moi.");
    managedSatellites = managedSatellitesDoc.to<JsonArray>();
    return;
  }

  DeserializationError error = deserializeJson(managedSatellitesDoc, file);
  file.close();

  if (error) {
    Serial.print("Loi doc file luu ve tinh: ");
    Serial.println(error.c_str());
    managedSatellites = managedSatellitesDoc.to<JsonArray>();
  } else {
    managedSatellites = managedSatellitesDoc.as<JsonArray>();
    Serial.printf("Da tai %d ve tinh tu bo nho.\n", managedSatellites.size());
  }
}

void saveManagedSatellites() {
  File file = SPIFFS.open(MANAGED_SATELLITES_FILE, "w");
  if (!file) {
    Serial.println("LOI: Khong the mo file de luu ve tinh!");
    return;
  }

  if (serializeJson(managedSatellitesDoc, file) == 0) {
    Serial.println("LOI: Ghi file luu ve tinh that bai!");
  } else {
    Serial.println("-> Da luu danh sach ve tinh vao SPIFFS.");
  }
  file.close();
}

void handleSatelliteDiscovery(byte* payload, unsigned int length) {
    DynamicJsonDocument doc(256);
    DeserializationError error = deserializeJson(doc, payload, length);
    if (error) return;

    const char* name = doc["name"];
    if (!name) return;

    Serial.printf("Nhan duoc 'announce' tu: %s\n", name);
    for (JsonObject managedSat : managedSatellites) {
        if (strcmp(managedSat["name"], name) == 0) {
            updateSatelliteStatus(name, doc.as<JsonObject>());
            return;
        }
    }

    bool alreadyDiscovered = false;
    for (JsonObject discoveredSat : discoveredSatellites) {
        if (strcmp(discoveredSat["name"], name) == 0) {
            discoveredSat["lastSeen"] = millis();
            if(doc.containsKey("ip")) discoveredSat["ip"] = doc["ip"].as<String>();
            alreadyDiscovered = true;
            break;
        }
    }

    if (!alreadyDiscovered) {
        JsonObject newSat = discoveredSatellites.createNestedObject();
        newSat["name"] = name;
        newSat["ip"] = doc["ip"] | "N/A";
        newSat["lastSeen"] = millis();
        Serial.printf(">>> Phat hien ve tinh moi: %s\n", name);
    }
    broadcastSatelliteStatus();
}

void handleSatelliteManagement(String topic, byte* payload, unsigned int length) {
    String deviceName;
    deviceName.reserve(length);
    for(unsigned int i = 0; i < length; i++) {
        deviceName += (char)payload[i];
    }

    if (topic == MANAGE_ADD_TOPIC) {
        Serial.printf("Nhan lenh THEM ve tinh: %s\n", deviceName.c_str());
        for (int i = 0; i < discoveredSatellites.size(); i++) {
            if (discoveredSatellites[i]["name"].as<String>() == deviceName) {
                JsonObject satToAdd = managedSatellites.createNestedObject();
                satToAdd["name"] = discoveredSatellites[i]["name"];
                satToAdd["ip"] = discoveredSatellites[i]["ip"];
                satToAdd["online"] = true;
                satToAdd["lastSeen"] = millis();

                discoveredSatellites.remove(i);
                saveManagedSatellites();
                broadcastSatelliteStatus();
                return;
            }
        }
    } else if (topic == MANAGE_REMOVE_TOPIC) {
        Serial.printf("Nhan lenh HUY ve tinh: %s\n", deviceName.c_str());
        for (int i = 0; i < managedSatellites.size(); i++) {
            if (managedSatellites[i]["name"].as<String>() == deviceName) {
                managedSatellites.remove(i);
                saveManagedSatellites();
                broadcastSatelliteStatus();
                return;
            }
        }
    }
}

void updateSatelliteStatus(const char* name, JsonObject statusData) {
    bool changed = false;
    for (JsonObject sat : managedSatellites) {
        if (strcmp(sat["name"], name) == 0) {
            bool isOnline = (strcmp(statusData["status"] | "offline", "online") == 0);
            if (sat["online"] != isOnline) {
                sat["online"] = isOnline;
                changed = true;
                Serial.printf("!!! CAP NHAT TRANG THAI: Ve tinh %s bay gio dang %s\n", name, isOnline ? "ONLINE" : "OFFLINE");
            }
            sat["lastSeen"] = millis();

            if (statusData.containsKey("ip")) sat["ip"] = statusData["ip"].as<String>();
            if (statusData.containsKey("rssi")) sat["rssi"] = statusData["rssi"].as<int>();
            if (statusData.containsKey("uptime")) sat["uptime"] = formatUptime(statusData["uptime"].as<unsigned long>());

            changed = true;
            break;
        }
    }
    if (changed) {
        broadcastSatelliteStatus();
    }
}

// TÌM HÀM NÀY VÀ SỬA LẠI
void broadcastSatelliteStatus() {
  if (webSocket.connectedClients() == 0 && !client.connected()) return;

  DynamicJsonDocument doc(2048);
  doc["type"] = "satellites_update";
  doc["managed"] = managedSatellites;
  doc["discovered"] = discoveredSatellites;
  doc["active_zones"] = activeZones; // <-- THÊM DÒNG NÀY

  String wsDataStr;
  serializeJson(doc, wsDataStr);

  if (webSocket.connectedClients() > 0) {
    webSocket.broadcastTXT(wsDataStr);
    Serial.println(">>> (MASTER) Da broadcast trang thai ve tinh (kem vung) den cac client LAN.");
  }

  doc.remove("type");
  String mqttDataStr;
  serializeJson(doc, mqttDataStr);
  if (client.connected()) {
    client.publish(MANAGE_STATUS_TOPIC, mqttDataStr.c_str(), true);
    Serial.println(">>> (MASTER) Da publish trang thai ve tinh (kem vung) len MQTT.");
  }
}
#endif

void saveNetworkConfig(bool use_static, const char* ip, const char* gateway, const char* subnet, const char* dns) {
  preferences.begin("net-config", false);
  // Mở preferences với namespace "net-config"
  preferences.putBool("use_static", use_static);
  preferences.putString("ip", ip);
  preferences.putString("gateway", gateway);
  preferences.putString("subnet", subnet);
  preferences.putString("dns", dns);
  preferences.end();
  Serial.println("-> Da luu cau hinh IP tinh vao Preferences.");
}void saveAllData() {
  preferences.begin("bell-data", false);
  String dataStr;
  serializeJson(allData, dataStr);
  preferences.putString("allData", dataStr);
  preferences.end();
  Serial.println("-> Da luu du lieu vao Preferences (NVS).");
}
void saveScenarioData() {
  preferences.begin("bell-scenario", false);
  String dataStr;
  serializeJson(scenarioDoc, dataStr);
  preferences.putString("scenario", dataStr);
  preferences.end();
  Serial.println("-> Da luu du lieu Kich Ban Hen Gio vao Preferences.");
}
// DÁN 2 HÀM NÀY VÀO GẦN CÁC HÀM save/read KHÁC

// Hàm lưu danh sách các vùng đang hoạt động
void saveActiveZones() {
  File file = SPIFFS.open(ACTIVE_ZONES_FILE, "w");
  if (!file) {
    Serial.println("LOI: Khong the mo file de luu vung hoat dong!");
    return;
  }
  if (serializeJson(activeZonesDoc, file) == 0) {
    Serial.println("LOI: Ghi file vung hoat dong that bai!");
  } else {
    Serial.println("-> Da luu danh sach vung hoat dong vao SPIFFS.");
  }
  file.close();
}

// Hàm đọc danh sách các vùng đang hoạt động từ bộ nhớ
void loadActiveZones() {
  File file = SPIFFS.open(ACTIVE_ZONES_FILE, "r");
  if (!file) {
    Serial.println("Khong tim thay file luu vung hoat dong, se tao moi.");
    activeZones = activeZonesDoc.to<JsonArray>();
    return;
  }
  DeserializationError error = deserializeJson(activeZonesDoc, file);
  file.close();
  if (error) {
    Serial.print("Loi doc file luu vung hoat dong: ");
    Serial.println(error.c_str());
    activeZones = activeZonesDoc.to<JsonArray>();
  } else {
    activeZones = activeZonesDoc.as<JsonArray>();
    Serial.printf("Da tai %d vung hoat dong tu bo nho.\n", activeZones.size());
  }
}
void loadScenarioData() {
  preferences.begin("bell-scenario", true);
  String dataStr = preferences.getString("scenario", "[]"); // Sửa default thành mảng rỗng
  preferences.end();
  
  DeserializationError error = deserializeJson(scenarioDoc, dataStr);
  if (error) {
    Serial.println("Loi parse JSON Kich Ban Hen Gio, tao du lieu rong.");
    scenarioDoc.clear();
    scenarioList = scenarioDoc.to<JsonArray>(); // Sửa thành scenarioList
  } else {
    scenarioList = scenarioDoc.as<JsonArray>(); // Sửa thành scenarioList
    Serial.println("Da doc du lieu Kich Ban Hen Gio tu Preferences thanh cong.");
  }
}
void readAllData() {
  preferences.begin("bell-data", true);
  String dataStr = preferences.getString("allData", "");
  preferences.end();
  if (dataStr.length() > 0) {
    DeserializationError error = deserializeJson(allData, dataStr);
    if (error) {
      Serial.println("Loi parse JSON tu Preferences, tao du lieu mac dinh.");
      createDefaultData();
      #if DEVICE_ROLE == ROLE_MASTER
      saveAllData();
      #endif
    } else {
      Serial.println("Da doc du lieu tu Preferences thanh cong.");
    }
  } else {
    Serial.println("Khong co du lieu trong Preferences, tao du lieu mac dinh.");
    createDefaultData();
    #if DEVICE_ROLE == ROLE_MASTER
    saveAllData();
    #endif
  }
}

// ===== [MỚI] CÁC HÀM DÀNH CHO LỊCH NGHỈ LỄ =====
void saveHolidayData() {
  preferences.begin("bell-holidays", false);
  String dataStr;
  serializeJson(holidayData, dataStr);
  preferences.putString("holidays", dataStr);
  preferences.end();
  Serial.println("-> Da luu du lieu ngay nghi vao Preferences (NVS).");
}

void readHolidayData() {
  preferences.begin("bell-holidays", true);
  String dataStr = preferences.getString("holidays", "{}");
  preferences.end();
  DeserializationError error = deserializeJson(holidayData, dataStr);
  if (error) {
    Serial.println("Loi parse JSON ngay nghi, tao du lieu rong.");
    holidayData.clear();
  } else {
    Serial.println("Da doc du lieu ngay nghi tu Preferences thanh cong.");
  }
}

// THAY THẾ TOÀN BỘ HÀM CŨ BẰNG HÀM NÀY
void startWiFiConnection() {
  preferences.begin("wifi-config", true);
  ssid_sta = preferences.getString("ssid_sta", "");
  pass_sta = preferences.getString("pass_sta", "");
  preferences.end();
  
  preferences.begin("net-config", true);
  bool useStatic = preferences.getBool("use_static", false);
  IPAddress staticIP, gateway, subnet, dns;
  if (useStatic) {
    staticIP.fromString(preferences.getString("ip", ""));
    gateway.fromString(preferences.getString("gateway", ""));
    subnet.fromString(preferences.getString("subnet", ""));
    dns.fromString(preferences.getString("dns", ""));
    Serial.println("-> Tim thay cau hinh IP tinh, se ap dung.");
  }
  preferences.end();

  WiFi.mode(WIFI_STA);

  // [FIX] Sửa đổi logic xử lý sự kiện kết nối lại WiFi
  WiFi.onEvent([](WiFiEvent_t event, WiFiEventInfo_t info){
    Serial.println("\n[WIFI EVENT] Da ket noi WiFi và nhận được IP!");
    ipAddress = WiFi.localIP().toString();
    Serial.println("Dia chi IP: " + ipAddress);
    wifiState = true;

    // Chủ động khởi tạo lại các dịch vụ mạng ngay lập tức
    if (!networkServicesInitialized) {
        initializeNetworkServices();
    }
    
    // Chủ động đồng bộ NTP và kết nối MQTT ngay khi có mạng
    // Hành động này giúp "khởi động nóng" lại toàn bộ kết nối Internet
    syncTimeWithNTP(); 
    reconnectMQTT();

  }, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_GOT_IP);

  // Logic xử lý khi mất kết nối (thêm vào để xử lý triệt để hơn)
  WiFi.onEvent([](WiFiEvent_t event, WiFiEventInfo_t info){
      Serial.println("\n[WIFI EVENT] Mat ket noi WiFi!");
      wifiState = false;
      networkServicesInitialized = false;
      ipAddress = "Mat ket noi...";
      if(client.connected()) {
          client.disconnect();
      }
  }, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_DISCONNECTED);


  #if DEVICE_ROLE == ROLE_MASTER
  if (ssid_sta == "") {
    wifiState = false;
    ipAddress = "192.168.4.1";
    Serial.println("Khong co cau hinh WiFi. Khoi dong che do Access Point (AP).");
    Serial.println("Ten WiFi: CHUONG_BAO_MAYCHU | Mat khau: 12345678");
    Serial.println("Truy cap IP: " + ipAddress + " de cai dat.");
    WiFi.mode(WIFI_AP_STA);
    WiFi.softAP("CHUONG_BAO_MAYCHU", "12345678");
    initializeNetworkServices();
    isInAPMode = true; 
    return;
  }
  #endif

  if (ssid_sta != "") {
    if (useStatic) {
      WiFi.config(staticIP, gateway, subnet, dns);
    }
    
    Serial.print("Bat dau ket noi den WiFi: ");
    Serial.println(ssid_sta);
    WiFi.begin(ssid_sta.c_str(), pass_sta.c_str());

    // Logic xử lý timeout khi kết nối lần đầu (giữ nguyên)
    unsigned long startTime = millis();
    while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
      if (millis() - startTime > 60000) {
        Serial.println("\nLOI: Khong the ket noi WiFi voi thong tin da luu.");
        #if DEVICE_ROLE == ROLE_MASTER
        Serial.println("Thong tin WiFi co the bi sai. KHOI DONG CHE DO AP DE CAI DAT.");
        WiFi.mode(WIFI_OFF);
        delay(100);
        WiFi.mode(WIFI_AP_STA);
        wifiState = false;
        ipAddress = "192.168.4.1";
        Serial.println("Ten WiFi: CHUONG_BAO_MAYCHU | Mat khau: 12345678");
        Serial.println("Truy cap IP: " + ipAddress + " de cai dat.");
        WiFi.softAP("CHUONG_BAO_MAYCHU", "12345678");
        initializeNetworkServices(); 
        isInAPMode = true;
        #endif
        return; 
      }
    }
  }
}
void broadcastTime() {
  #if DEVICE_ROLE == ROLE_MASTER
  // [SỬA] Thay thế authoritativeEpoch bằng cờ time_is_set
  if (!time_is_set || webSocket.connectedClients() == 0) return;
  DynamicJsonDocument doc(128);
  doc["type"] = "time_update";
  doc["epoch"] = time(NULL);

  String dataStr;
  serializeJson(doc, dataStr);
  webSocket.broadcastTXT(dataStr);
  #endif
}
// Dán hàm mới này vào khoảng dòng 483, ngay trên hàm checkTime()


void checkTime() {
  if (!time_is_set) return;
  
  struct tm timeinfo;
  // Lấy thời gian từ software RTC nội bộ của ESP32
  if(!getLocalTime(&timeinfo)){
    Serial.println("Loi khi doc thoi gian he thong!");
    return;
  }
  
  // Cập nhật các biến thời gian toàn cục để hiển thị và tính toán
  gio = timeinfo.tm_hour;
  phut = timeinfo.tm_min;
  giay = timeinfo.tm_sec;
  ngay = timeinfo.tm_mday;
  thang = timeinfo.tm_mon + 1;
  nam = timeinfo.tm_year + 1900;
  thu = timeinfo.tm_wday;

  char dateString[11];
  sprintf(dateString, "%04d-%02d-%02d", nam, thang, ngay);
  if (holidayData.containsKey(dateString)) {
      return; // Bỏ qua nếu là ngày nghỉ
  }
  
  // Khi đến giây 0 của mỗi phút, kiểm tra lịch và in thời gian
  if (giay == 0) {
    Serial.printf("[TIME] %02d/%02d/%04d - %02d:%02d:%02d (DayKey: %d)\n", ngay, thang, nam, gio, phut, giay, thu);
    time_to_check_schedule = true; // Bật cờ để loop() kiểm tra lịch
  }

  // Cập nhật LCD và broadcast thời gian
  updateLcdDisplay();
  if (giay == 0 || giay == 30) {
    broadcastTime();
  }
}

void controlRelay(int num) {
  if (num <= 0) return;
  int on_ms = allData["sohoi"]["tg_reo"] | 1000;
  int off_ms = allData["sohoi"]["tg_nghi"] | 1000;
  for (int i = 0; i < num; ++i) {
    digitalWrite(relay, HIGH);
    delay(on_ms);
    digitalWrite(relay, LOW);
    if (i < num - 1) {
      delay(off_ms);
    }
  }
}

void createDefaultData() {
  const char* defaultJson = R"({"sohoi":{"batdau":{"num":6,"action":"bell","track":"","volume":25},"vaotiet":{"num":5,"action":"bell","track":"","volume":25},"rachoi":{"num":3,"action":"music","track":"Nhac-Khong-Loi-Soi-Dong.mp3","volume":20,"random":true},"duvao":{"num":2,"action":"bell","track":"","volume":25},"tg_reo":1000,"tg_nghi":1000},"lich":{"sang":{"t2":{"enabled":true,"gio":"07:00","has_special_event":true,"chaoco":40,"prepare_after_special":2,"tiethoc":45,"rachoi":"5,15,5,5","has_duvao_bell":true,"duvaotiet":3,"sotiet":5},"t3":{"enabled":true,"gio":"07:00","has_special_event":true,"chunhiem":15,"prepare_after_special":2,"tiethoc":45,"rachoi":"5","has_duvao_bell":true,"duvaotiet":3,"sotiet":5},"t4":{"enabled":true,"gio":"07:00","has_special_event":false,"chunhiem":15,"prepare_after_special":2,"tiethoc":45,"rachoi":"5","has_duvao_bell":true,"duvaotiet":3,"sotiet":5},"t5":{"enabled":true,"gio":"07:00","has_special_event":false,"chunhiem":15,"prepare_after_special":2,"tiethoc":45,"rachoi":"5","has_duvao_bell":true,"duvaotiet":3,"sotiet":5},"t6":{"enabled":true,"gio":"07:00","has_special_event":false,"chunhiem":15,"prepare_after_special":2,"tiethoc":45,"rachoi":"5","has_duvao_bell":true,"duvaotiet":3,"sotiet":5},"t7":{"enabled":true,"gio":"07:00","has_special_event":true,"chunhiem":15,"prepare_after_special":2,"tiethoc":45,"rachoi":"5","has_duvao_bell":true,"duvaotiet":3,"sotiet":5},"cn":{"enabled":false,"gio":"07:00","has_special_event":false,"chunhiem":15,"prepare_after_special":2,"tiethoc":45,"rachoi":"5","has_duvao_bell":true,"duvaotiet":3,"sotiet":5}},"chieu":{"t2":{"enabled":true,"gio":"13:30","has_special_event":false,"chunhiem":15,"prepare_after_special":5,"tiethoc":45,"rachoi":"10","has_duvao_bell":true,"duvaotiet":3,"sotiet":4},"t3":{"enabled":true,"gio":"13:30","has_special_event":false,"chunhiem":15,"prepare_after_special":5,"tiethoc":45,"rachoi":"10","has_duvao_bell":true,"duvaotiet":3,"sotiet":4},"t4":{"enabled":true,"gio":"13:30","has_special_event":false,"chunhiem":15,"prepare_after_special":5,"tiethoc":45,"rachoi":"10","has_duvao_bell":true,"duvaotiet":3,"sotiet":4},"t5":{"enabled":true,"gio":"13:30","has_special_event":false,"chunhiem":15,"prepare_after_special":5,"tiethoc":45,"rachoi":"10","has_duvao_bell":true,"duvaotiet":3,"sotiet":4},"t6":{"enabled":true,"gio":"13:30","has_special_event":false,"chunhiem":15,"prepare_after_special":5,"tiethoc":45,"rachoi":"10","has_duvao_bell":true,"duvaotiet":3,"sotiet":4},"t7":{"enabled":false,"gio":"13:30","has_special_event":false,"chunhiem":15,"prepare_after_special":5,"tiethoc":45,"rachoi":"10","has_duvao_bell":true,"duvaotiet":3,"sotiet":4},"cn":{"enabled":false,"gio":"13:30","has_special_event":false,"chunhiem":15,"prepare_after_special":5,"tiethoc":45,"rachoi":"10","has_duvao_bell":true,"duvaotiet":3,"sotiet":4}}}})";
  deserializeJson(allData, defaultJson);
}
#if DEVICE_ROLE == ROLE_MASTER
void sendInitialDataTask(void *param) {
  // Lấy lại client ID từ tham số
  uint8_t num = (uint8_t)(uintptr_t)param; 
  if (!isInAPMode) {
      Serial.printf("[Task] Client [%u] da ket noi. Dang cho NTP sync...\n", num); 
    unsigned long waitStartTime = millis(); 
      // [SỬA] Thay thế authoritativeEpoch bằng cờ time_is_set
      while (!time_is_set) { 
          vTaskDelay(200 / portTICK_PERIOD_MS);
          if (millis() - waitStartTime > 30000) { 
              Serial.printf("[Task] LOI: Timeout 30s cho viec lay thoi gian for client [%u]. Huy task.\n", num);
              vTaskDelete(NULL); 
              return; 
          }
      }
      Serial.printf("[Task] Da co NTP. Bat dau gui du lieu khoi tao cho client [%u]...\n", num); 
  } else {
      Serial.printf("[Task] Client [%u] ket noi o che do AP. Bo qua cho NTP.\n", num);
      vTaskDelay(100 / portTICK_PERIOD_MS); // Chờ 100ms cho kết nối ổn định
  }
  
  DynamicJsonDocument timeDoc(128);
      timeDoc["type"] = "time_update"; 
       timeDoc["epoch"] = time(NULL); 
      String timeStr;
      serializeJson(timeDoc, timeStr);
      webSocket.sendTXT(num, timeStr); 
      Serial.printf("  -> [Task] Da gui [Time Update] (NHE) cho client [%u]\n", num); 
  vTaskDelay(50 / portTICK_PERIOD_MS);
  
  // 1. GỬI LỊCH HỌC
  DynamicJsonDocument scheduleDoc(4096); 
  scheduleDoc["type"] = "schedule_update"; 
  scheduleDoc["data"]["schedule"] = allData; 
  
  String outputSchedule;
  serializeJson(scheduleDoc, outputSchedule); 
  webSocket.sendTXT(num, outputSchedule); 
  Serial.printf("  -> [Task] Da gui [Lich Hoc] (NANG) cho client [%u]\n", num); 
  
  vTaskDelay(50 / portTICK_PERIOD_MS); 
  // 2. GỬI LỊCH NGHỈ
  DynamicJsonDocument holidayDoc(1280); 
  holidayDoc["type"] = "schedule_update"; 
  holidayDoc["data"]["holidays"] = holidayData; 
  String outputHoliday;
  serializeJson(holidayDoc, outputHoliday); 
  webSocket.sendTXT(num, outputHoliday); 
  Serial.printf("  -> [Task] Da gui [Lich Nghi] cho client [%u]\n", num);
  
  vTaskDelay(50 / portTICK_PERIOD_MS); 
  // 3. GỬI KỊCH BẢN (Đã là mảng, logic này chính xác)
  DynamicJsonDocument scenarioPkt(2304); 
  scenarioPkt["type"] = "schedule_update"; 
  scenarioPkt["data"]["scenario"] = scenarioDoc; 
  String outputScenario;
  serializeJson(scenarioPkt, outputScenario);
  webSocket.sendTXT(num, outputScenario); 
  Serial.printf("  -> [Task] Da gui [Kich Ban] cho client [%u]\n", num); 
  
  vTaskDelay(50 / portTICK_PERIOD_MS); 
  // 4. GỬI TRẠNG THÁI NHẠC
  sendMusicStatusToClient(num);
  Serial.printf("  -> [Task] Da gui [Am Nhac] cho client [%u]\n", num); 
  // --- KẾT THÚC TÁC VỤ NẶNG ---
  
  Serial.printf("[Task] Hoan tat gui du lieu cho client [%u]. Xoa task.\n", num);

  vTaskDelete(NULL); 
}
// === [THAY THẾ TOÀN BỘ HÀM NÀY] ===
#if DEVICE_ROLE == ROLE_MASTER
void webSocketEvent(uint8_t num, WStype_t type, uint8_t *payload, size_t length) {
  switch (type) {
    case WStype_DISCONNECTED:
      Serial.printf("[%u] Client LAN da ngat ket noi!\n", num);
      break;
      
    case WStype_CONNECTED: {
      Serial.printf("[%u] Client LAN da ket noi!\n", num);
      Serial.printf("  -> Da gui 'Time' (NON-BLOCKING) cho client [%u]\n", num);
   
      xTaskCreate(
        sendInitialDataTask, 
        "wsInitTask",           
        10240,                 
        (void*)(uintptr_t)num,  
        1,                      
        NULL                   
      );
      Serial.printf("  -> Da khoi chay Task nen de gui du lieu nang cho [%u]\n", num);
      break;
    }
    

case WStype_TEXT: {
  DynamicJsonDocument doc(4096);
  DeserializationError error = deserializeJson(doc, payload, length);
  
  if (error) {
    String payloadString = "";
    for(size_t i=0; i < length; i++) { payloadString += (char)payload[i]; }
    if (payloadString == "TEST_BELL") {
      Serial.println("Nhan lenh TEST_BELL tu web LAN, bat dau reo chuong toan he thong.");
      controlRelay(3);
    }
    return;
  }
  
  const char* commandType = doc["type"];
  if (!commandType) return;
  if (strcmp(commandType, "SET_DATA") == 0) {
      Serial.println(">>> (LAN) Nhan du lieu LICH HOC & LICH NGHI tu WebSocket.");
      JsonObject dataPayload = doc["payload"];
      
      if (dataPayload.containsKey("schedule")) {
          ticker.detach();
          JsonObject newSchedule = dataPayload["schedule"];
          if (newSchedule.containsKey("sohoi")) {
            allData["sohoi"] = newSchedule["sohoi"];
          }
          if (newSchedule.containsKey("lich")) {
            allData["lich"] = newSchedule["lich"];
          }
          saveAllData();
          if(!ticker.active()) ticker.attach(1, checkTime);
          Serial.println(">>> (LAN) Da luu Lich Hoc.");
      }
      
      if (dataPayload.containsKey("holidays")) { 
          holidayData = dataPayload["holidays"].as<JsonObject>();
          saveHolidayData(); 
          Serial.println(">>> (LAN) Da luu Lich Nghi.");
          broadcastAndPublishState();
          showNotification("success", "Đã lưu Lịch nghỉ.");
      } else {
          if (dataPayload.containsKey("schedule")) {
             broadcastAndPublishState();
             showNotification("success", "Đã lưu Lịch học & Lịch nghỉ.");
          }
      }
      return;
  } 
// === BẮT ĐẦU THÊM KHỐI CODE MỚI VÀO ĐÂY ===
  else if (strcmp(commandType, "SET_ZONE_STATUS") == 0) {
      JsonObject payload = doc["payload"];
      const char* name = payload["name"];
      bool isActive = payload["active"];

      if (name) {
          Serial.printf("Nhan lenh cap nhat vung: %s -> %s\n", name, isActive ? "BAT" : "TAT");

          // Xóa tên cũ nếu có
          for (int i = 0; i < activeZones.size(); i++) {
              if (activeZones[i].as<String>() == name) {
                  activeZones.remove(i);
                  break;
              }
          }

          // Nếu trạng thái là BẬT, thêm lại vào danh sách
          if (isActive) {
              activeZones.add(name);
          }
          
          saveActiveZones(); // Lưu thay đổi
          broadcastSatelliteStatus(); // Gửi lại trạng thái mới cho tất cả client
      }
      return;
  }
  // === KẾT THÚC KHỐI CODE MỚI ===
 else if (strcmp(commandType, "SYNC_TIME") == 0) {
      Serial.println(">>> (LAN) Nhan lenh dong bo thoi gian NTP thu cong.");
      showNotification("info", "Bắt đầu đồng bộ thời gian..."); 

      // [SỬA] Gọi hàm đồng bộ trước
      syncTimeWithNTP();
      
      // Đợi một chút để hàm có thời gian chạy
      delay(100);

      // Kiểm tra kết quả qua cờ time_is_set
      if (time_is_set) {
          Serial.println(">>> (LAN) Dong bo NTP thu cong thanh cong.");
          showNotification("success", "Đồng bộ thời gian thành công!");
      } else {
          Serial.println("!!! LOI: (LAN) Dong bo NTP thu cong that bai.");
          showNotification("error", "Lỗi: Đồng bộ thời gian thất bại!");
      }
      return;
  }
// ================ THÊM CODE MỚI VÀO ĐÂY =================
  else if (strcmp(commandType, "MANUAL_SYNC_TIME") == 0) {
      Serial.println(">>> (LAN) Nhan lenh dong bo thoi gian thu cong TU TRINH DUYET.");
      JsonObject payload = doc["payload"];
      unsigned long newEpoch = payload["epoch"];

      // Kiểm tra xem epoch có hợp lệ không (vd: lớn hơn 1/1/2021)
      if (newEpoch > 1609459200) { 
          timeval tv = { (time_t)newEpoch, 0 };
          settimeofday(&tv, nullptr);
          time_is_set = true;
          
          if (rtc_available) {
              rtc.adjust(DateTime(newEpoch));
              Serial.println(">>> Da cap nhat thoi gian cho DS3231 tu trinh duyet!");
      }
              updateLcdDisplay();       // Vẽ lại màn hình LCD ngay lập tức   
          // QUAN TRỌNG: Khởi động ticker ngay nếu nó chưa chạy
          if (!ticker.active()) {
              ticker.attach(1, checkTime);
              Serial.println(">>> DA CO EPOCH (tu trinh duyet). Khoi dong dong ho he thong (ticker).");
          }
          
          Serial.printf("[TIME] Nhan epoch moi: %lu\n", newEpoch);
          showNotification("success", "Đồng bộ thời gian từ trình duyệt thành công!");

          // Gửi lại thời gian đã cập nhật cho tất cả client
          DynamicJsonDocument timeDoc(128);
          timeDoc["type"] = "time_update";
           timeDoc["epoch"] = time(NULL);
          String timeStr;
          serializeJson(timeDoc, timeStr);
          webSocket.broadcastTXT(timeStr);

      } else {
          Serial.println("[TIME] LOI: Nhan duoc epoch khong hop le tu trinh duyet.");
          showNotification("error", "Lỗi: Thời gian nhận được không hợp lệ.");
      }
      return;
  }
  else if (strcmp(commandType, "ADD_SCENARIO") == 0) {
      Serial.println(">>> (LAN) Nhan lenh THEM KICH BAN MOI.");
      JsonObject scenarioPayload = doc["payload"];
      
      if (scenarioList.add(scenarioPayload)) {
           Serial.println(">>> (LAN) Da them kich ban moi vao danh sach.");
           saveScenarioData();
           broadcastAndPublishState();
           showNotification("success", "Đã THÊM kịch bản mới.");
      } else {
           Serial.println("!!! LOI: (LAN) Khong du bo nho de them kịch bản!");
           showNotification("error", "Lỗi: Không đủ bộ nhớ!");
      }
      return;
  }
  
  else if (strcmp(commandType, "DELETE_ALL_SCENARIOS") == 0) {
      Serial.println(">>> (LAN) Nhan lenh XOA TAT CA kịch bản.");
      scenarioDoc.clear();
      scenarioList = scenarioDoc.to<JsonArray>();
      saveScenarioData();
      broadcastAndPublishState();
      showNotification("success", "Đã XÓA TẤT CẢ kịch bản.");
      return;
  }

  else if (strcmp(commandType, "DELETE_SCENARIO_INDEX") == 0) {
      int indexToRemove = doc["payload"].as<int>();
      Serial.printf(">>> (LAN) Nhan lenh XOA KICH BAN tai vi tri: %d\n", indexToRemove);
      if (indexToRemove >= 0 && indexToRemove < scenarioList.size()) {
          scenarioList.remove(indexToRemove);
          Serial.printf(">>> (LAN) Da xoa kich ban tai vi tri %d.\n", indexToRemove);
          saveScenarioData();
          broadcastAndPublishState();

          showNotification("success", "Đã xóa kịch bản.");
      } else {
          Serial.printf("!!! LOI: (LAN) Vi tri xoa khong hop le: %d.\n", indexToRemove);
          showNotification("error", "Lỗi: Vị trí xóa không hợp lệ.");
      }
      return;
  }

  else if (strcmp(commandType, "MUSIC_COMMAND") == 0) {
      Serial.println(">>> (LAN) Nhan lenh Dieu Khien Nhac tu WebSocket.");
      JsonObject musicPayload = doc["payload"];
      handleMusicControl(musicPayload);
      return;
  }

  else if (strcmp(commandType, "TEST_MQTT") == 0) {
    JsonObject data = doc["data"];
    const char* server = data["server"];
    int port = data["port"];
    const char* user = data["user"];
    const char* pass = data["pass"];
    Serial.printf("Nhan lenh kiem tra MQTT: %s:%d\n", server, port);

    if (client.connected()) {
      client.disconnect();
    }
    delay(100);

    client.setServer(server, port);
    String clientId = String(DEVICE_NAME) + "-Test-" + String(random(0xffff), HEX);
    bool test_result = client.connect(clientId.c_str(), user, pass);
    StaticJsonDocument<256> response_doc;
    response_doc["type"] = "MQTT_TEST_RESULT";
    if (test_result) {
      Serial.println(">>> KET NOI THU THANH CONG!");
      response_doc["status"] = "success";
      response_doc["message"] = "Kết nối thành công!";
    } else {
      Serial.println(">>> KET NOI THU THAT BAI!");
      response_doc["status"] = "error";
      response_doc["message"] = "Kết nối thất bại, rc=" + String(client.state()) + ". Vui lòng kiểm tra lại thông tin.";
      reconnectMQTT();
    }
    String response_payload;
    serializeJson(response_doc, response_payload);
    webSocket.sendTXT(num, response_payload);
  } 
  else if (strcmp(commandType, "SAVE_MQTT") == 0) {
    JsonObject data = doc["data"];
    const char* server = data["server"];
    int port = data["port"];
    const char* user = data["user"];
    const char* pass = data["pass"];
    saveMqttConfig(server, port, user, pass);
    strncpy(mqtt_server, server, sizeof(mqtt_server) - 1);
    mqtt_port = port;
    strncpy(mqtt_username, user, sizeof(mqtt_username) - 1);
    strncpy(mqtt_password, pass, sizeof(mqtt_password) - 1);
    Serial.println("!!! Da luu vinh vien cau hinh MQTT moi.");

    StaticJsonDocument<128> response_doc;
    response_doc["type"] = "MQTT_SAVE_RESULT";
    response_doc["message"] = "Đã lưu cấu hình MQTT thành công!";
    String response_payload;
    serializeJson(response_doc, response_payload);
    webSocket.sendTXT(num, response_payload);
  }
  else if (strcmp(commandType, "SAVE_NETWORK_CONFIG") == 0) {
    JsonObject data = doc["data"];
    bool use_static = data["use_static"];
    
    saveNetworkConfig(
      use_static,
      data["ip"],
      data["gateway"],
      data["subnet"],
      data["dns"]
    );
    webSocket.sendTXT(num, "{\"type\":\"NET_SAVE_RESULT\", \"message\":\"Đã lưu, đang khởi động lại...\"}");
    delay(1000);
    ESP.restart();
  }
  break;
    } 
  }
}

void showNotification(const char* status, const char* message) {
    DynamicJsonDocument doc(128);
    doc["type"] = "notification";
    doc["status"] = status;
    doc["message"] = message;
    String output;
    serializeJson(doc, output);
    webSocket.broadcastTXT(output);
}
#endif

void sendMusicStatusToClient(uint8_t num) {

  DynamicJsonDocument doc(2048); 
  doc["type"] = "music_status";
  JsonObject data = doc.to<JsonObject>();
  data.set(musicStatusDoc.as<JsonObject>()); 

  String output;
  serializeJson(doc, output);
  webSocket.sendTXT(num, output); 
  Serial.printf("    -> Da gui trang thai am nhac den client LAN [%u].\n", num);
}
void sendSatelliteStatusToClient(uint8_t num) {
  DynamicJsonDocument doc(2048);
  doc["type"] = "satellites_update";
  doc["managed"] = managedSatellites;
  doc["discovered"] = discoveredSatellites;

  String output;
  serializeJson(doc, output);
  webSocket.sendTXT(num, output);
  Serial.printf("    -> Da gui trang thai ve tinh den client LAN [%u].\n", num);
}
#endif
#if DEVICE_ROLE == ROLE_MASTER
void setupWebServer() {
  webServer.on("/home.html.gz", HTTP_GET, [](AsyncWebServerRequest *request){
    AsyncWebServerResponse *response = request->beginResponse(SPIFFS, "/home.html.gz", "text/html");
    response->addHeader("Content-Encoding", "gzip"); 
    request->send(response);
  });
  webServer.on("/login.html", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(SPIFFS, "/login.html", "text/html");
  });

  webServer.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->redirect("/home.html.gz"); 
  });

  webServer.on("/setup", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send_P(200, "text/html", SETUP_HTML);
  });
  
  webServer.on("/getWifiList", HTTP_GET, [](AsyncWebServerRequest *request) {
    Serial.println("Nhan yeu cau quet WiFi tu web...");
    int n = WiFi.scanNetworks();
    DynamicJsonDocument doc(1024);
    JsonArray ssidList = doc.createNestedArray("ssidList");
    for (int i = 0; i < n; ++i) {
      ssidList.add(WiFi.SSID(i));
    }
    String response;
    serializeJson(doc, response);
    request->send(200, "application/json", response);
    Serial.printf("Da quet va tra ve %d mang WiFi.\n", n);
  });

  webServer.on("/saveConfig", HTTP_POST, [](AsyncWebServerRequest *request) {}, NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {
    StaticJsonDocument<256> doc;
    deserializeJson(doc, (const char*)data);
    ssid_sta = doc["ssid_sta"].as<String>();
    pass_sta = doc["pass_sta"].as<String>();
    
    preferences.begin("wifi-config", false);
    preferences.putString("ssid_sta", ssid_sta);
    preferences.putString("pass_sta", pass_sta);
    preferences.end();
    
    Serial.println("Da luu cau hinh WiFi moi. Dang khoi dong lai...");
    request->send(200, "text/plain", "Đã lưu cấu hình WiFi. Thiết bị sẽ khởi động lại sau vài giây.");
    delay(2000);
    ESP.restart();
  });

  webServer.on("/login", HTTP_POST, [](AsyncWebServerRequest *request) {}, NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {
    StaticJsonDocument<128> doc;
    deserializeJson(doc, (const char*)data);
    const char* password = doc["password"];
    
    StaticJsonDocument<128> responseDoc;
    if (password && strcmp(password, ADMIN_PASSWORD) == 0) {
      responseDoc["success"] = true;
      Serial.println("Xac thuc web thanh cong.");
    } else {
      responseDoc["success"] = false;
      Serial.println("LOI: Xac thuc web that bai!");
    }
    String response;
    serializeJson(responseDoc, response);
    request->send(200, "application/json", response);
  });

  webServer.begin();
  Serial.println("Web Server da khoi dong.");
}

 #endif

int timeToMinute(String t) {
  if (t == "") return 0;
  int colonIndex = t.indexOf(":");
  int hour = t.substring(0, colonIndex).toInt();
  int minute = t.substring(colonIndex + 1).toInt();
  return hour * 60 + minute;
}

String minuteToTime(int totalMinutes) {
  int hour = totalMinutes / 60;
  int minute = totalMinutes % 60;
  char timeStr[6];
  sprintf(timeStr, "%02d:%02d", hour, minute);
  return String(timeStr);
}

void handleResetButton() {
  boolean btSetupState = digitalRead(btSetup);
  static unsigned long timePush = 0;
  static boolean isCounting = false;
  if (btSetupState == LOW) {
    if (!isCounting) { timePush = millis(); isCounting = true;
    }

    digitalWrite(ledSignal, !digitalRead(ledSignal));
    if (millis() - timePush > 15000) {
      Serial.println("!!! GIU NUT 15 GIAY - XOA TOAN BO CAU HINH !!!");
      preferences.begin("bell-data", false);
      preferences.clear();
      preferences.end();
      
      preferences.begin("wifi-config", false);
      preferences.clear();
      preferences.end();
      
      Serial.println("Da xoa du lieu. Khoi dong lai...");
      digitalWrite(ledSignal, HIGH);
      delay(2000);
      ESP.restart();
    }
  } else {
    isCounting = false;
    digitalWrite(ledSignal, LOW);
  }
}
